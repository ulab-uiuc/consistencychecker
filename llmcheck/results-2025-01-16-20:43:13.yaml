evaluator_model: {model: 'ollama_chat/llama3.1:8b-instruct-fp16', temperature: 0.6,
  api_base: 'http://localhost:11434'}
evaluatee_model: {model: 'ollama_chat/llama3.1:8b-instruct-fp16', temperature: 0.6,
  api_base: 'http://localhost:11434'}
root_content: &id001
  description: '**Fractal Dimension Estimation**

    ===


    Given an array of integers representing the length and width of squares in a recursive
    fractal pattern,

    estimate the fractal dimension using the Box Counting method.


    The fractal is generated by recursively splitting each square into four smaller
    squares with half the side length.

    The number of squares at each level of recursion forms a sequence that can be
    used to estimate the fractal dimension.


    **Example:**

    Input: [1, 2, 4, 8]

    Output: 2.0

    '
  code: "def main(squares):\n    n = len(squares)\n    levels = 0\n    while (n >\
    \ 1 and squares[0] == squares[-1]):\n        squares = [s // 2 for s in squares]\n\
    \        n //= 2\n        levels += 1\n    if n != 1:\n        return -1.0\n \
    \   else:\n        return levels + 1\n"
  programming_language: python3
  inputs: &id002
  - squares: [1, 2, 4, 8]
  - squares: [16, 32, 64, 128]
  - squares: [256, 512, 1024, 2048]
  - squares: [65536, 131072, 262144, 524288]
  - squares: [1, 2, 3, 4]
  - squares: [5, 10, 20, 40]
  - squares: [100, 200, 400, 800]
  - squares: [2000, 4000, 8000, 16000]
  - squares: [1, 2, 4, 8, 16]
  - squares: [32, 64, 128, 256, 512]
  - squares: [1024, 2048, 4096, 8192, 16384]
  - squares: [65536, 131072, 262144, 524288, 1048576]
  - squares: [1, 3, 9, 27, 81]
  - squares: [125, 375, 1125, 3375, 10125]
  - squares: [1000, 3000, 9000, 27000, 81000]
  - squares: [2, 6, 18, 54, 162]
  - squares: [50, 150, 450, 1350, 4050]
  - squares: [500, 1500, 4500, 13500, 40500]
  exec_results: &id003 [-1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0,
    -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0]
operations:
- !!python/tuple ['1. Transform operation: Replace the while loop with a recursive
    function call to reduce(squares) where reduction logic is implemented in a separate
    function, utilizing memoization to optimize performance', 'Reverse operation:
    Revert the code back to using a traditional while loop and remove the separate
    reduction function.']
- !!python/tuple ['2. Transform operation: Implement dynamic programming by introducing
    an auxiliary "reduction_table" dictionary that stores intermediate results of
    sub-problems, accessed via the squares list as keys, allowing for efficient caching
    of computations', 'Reverse operation: Eliminate the "reduction_table" dictionary
    and revert to computing each value directly within the while loop.']
metrics:
  L-1 AVG: 0.9999999999999999
  L-1: [0.9999999999999998, 0.9999999999999998, 0.9999999999999998, 0.9999999999999998,
    0.9999999999999998, 0.9999999999999998]
  L-2 AVG: 0.9999996956197889
  L-2: [0.9999999999999998, 0.9999999999999998, 0.9999999999999998, 0.9999987824791564]
  L-3 AVG: 0.0
  L-3: []
  L-5 AVG: 0.0
  L-5: []
tree: !!python/object:llmcheck.core.tree.EvaluationTree
  root: &id004 !!python/object:llmcheck.nodes.node.Node
    content: *id001
    operation: null
    middle_state: null
    parent: null
    children:
    - &id005 !!python/object:llmcheck.nodes.node.Node
      content:
        description: '**Fractal Dimension Estimation**

          ===


          Given an array of integers representing the length and width of squares
          in a recursive fractal pattern,

          estimate the fractal dimension using the Box Counting method.


          The fractal is generated by recursively splitting each square into four
          smaller squares with half the side length.

          The number of squares at each level of recursion forms a sequence that can
          be used to estimate the fractal dimension.


          **Example:**

          Input: [1, 2, 4, 8]

          Output: 2.0

          '
        code: "def main(squares):\n    memo = {}\n    n = len(squares)\n    levels\
          \ = 0\n    while (n > 1 and squares[0] == squares[-1]):\n        squares\
          \ = [s // 2 for s in squares]\n        n //= 2\n        levels += 1\n  \
          \  if n != 1:\n        return -1.0\n    else:\n        result = float('inf')\n\
          \        for i in range(n):\n            for j in range(i, n):\n       \
          \         if i == j:\n                    temp_result = 0\n            \
          \    else:\n                    left = 0\n                    for k in range(i,\
          \ j):\n                        left += reduce(squares[i:k])\n          \
          \          right = 0\n                    for k in range(j, n):\n      \
          \                  right += reduce(squares[k:j+1])\n                   \
          \ temp_result = min(left + right + (squares[j] if i != j else squares[j]),\
          \ result)\n                result = min(result, temp_result)\n        return\
          \ result + levels + 1\n\ndef reduce(squares):\n    memo = {}\n    n = len(squares)\n\
          \    def helper(i, j):\n        if (i, j) in memo:\n            return memo[(i,\
          \ j)]\n        if i == j:\n            return 0\n        result = float('inf')\n\
          \        for k in range(i, j+1):\n            left = reduce(squares[i:k])\n\
          \            right = reduce(squares[k:j+1])\n            result = min(result,\
          \ left + right + (squares[k-1] if i != k else squares[k]) == (squares[j]\
          \ if i != k else squares[k]))\n        memo[(i, j)] = result\n        return\
          \ result\n    return helper(0, n-1)"
        programming_language: python3
        inputs: *id002
        exec_results: *id003
      operation: !!python/tuple ['1. Transform operation: Replace the while loop with
          a recursive function call to reduce(squares) where reduction logic is implemented
          in a separate function, utilizing memoization to optimize performance',
        'Reverse operation: Revert the code back to using a traditional while loop
          and remove the separate reduction function.']
      middle_state:
        description: '**Fractal Dimension Estimation**

          ===


          Given an array of integers representing the length and width of squares
          in a recursive fractal pattern,

          estimate the fractal dimension using the Box Counting method.


          The fractal is generated by recursively splitting each square into four
          smaller squares with half the side length.

          The number of squares at each level of recursion forms a sequence that can
          be used to estimate the fractal dimension.


          **Example:**

          Input: [1, 2, 4, 8]

          Output: 2.0

          '
        code: "def reduce(squares):\n    memo = {}\n    def helper(i, j):\n      \
          \  if (i, j) in memo:\n            return memo[(i, j)]\n        if i ==\
          \ j:\n            return 0\n        result = float('inf')\n        for k\
          \ in range(i, j+1):\n            left = reduce(squares[i:k])\n         \
          \   right = reduce(squares[k:j+1])\n            result = min(result, left\
          \ + right + (squares[k-1] if i != k else squares[k]) == (squares[j] if i\
          \ != k else squares[k]))\n        memo[(i, j)] = result\n        return\
          \ result\n    return helper(0, len(squares)-1)\n\ndef main(squares):\n \
          \   n = len(squares)\n    levels = 0\n    while (n > 1 and squares[0] ==\
          \ squares[-1]):\n        squares = [s // 2 for s in squares]\n        n\
          \ //= 2\n        levels += 1\n    if n != 1:\n        return -1.0\n    else:\n\
          \        return reduce(squares) + 1"
        programming_language: python3
        inputs: *id002
        exec_results: *id003
      parent: *id004
      children:
      - !!python/object:llmcheck.nodes.node.Node
        content:
          description: '**Fractal Dimension Estimation**

            ===


            Given an array of integers representing the length and width of squares
            in a recursive fractal pattern,

            estimate the fractal dimension using the Box Counting method.


            The fractal is generated by recursively splitting each square into four
            smaller squares with half the side length.

            The number of squares at each level of recursion forms a sequence that
            can be used to estimate the fractal dimension.


            **Example:**

            Input: [1, 2, 4, 8]

            Output: 2.0

            '
          code: "def main(squares):\n    memo = {}\n    n = len(squares)\n    levels\
            \ = 0\n    while (squares, ) not in memo:\n        result = float('inf')\n\
            \        for i in range(2**len(squares)):\n            temp_squares =\
            \ []\n            for j in range(len(squares)):\n                if (i\
            \ & (1 << j)) > 0:\n                    temp_squares.append(squares[j])\n\
            \            if len(temp_squares) == 1:\n                result = min(result,\
            \ levels + 1)\n            else:\n                temp_result = levels\
            \ + 1\n                for k in range(len(temp_squares) - 1):\n      \
            \              temp_result += reduce([temp_squares[k], temp_squares[k+1]])\n\
            \                result = min(result, temp_result)\n        memo[(squares,\
            \ )] = result\n    return memo[(squares, )]\n\ndef reduce(squares):\n\
            \    if (squares, ) in memo:\n        return memo[(squares, )]\n    result\
            \ = float('inf')\n    for i in range(2**len(squares)):\n        temp_squares\
            \ = []\n        for j in range(len(squares)):\n            if (i & (1\
            \ << j)) > 0:\n                temp_squares.append(squares[j])\n     \
            \   if len(temp_squares) == 1:\n            result = min(result, levels\
            \ + 1)\n        else:\n            temp_result = levels + 1\n        \
            \    for k in range(len(temp_squares) - 1):\n                temp_result\
            \ += reduce([temp_squares[k], temp_squares[k+1]])\n            result\
            \ = min(result, temp_result)\n    memo[(squares, )] = result\n    return\
            \ result"
          programming_language: python3
          inputs: *id002
          exec_results: *id003
        operation: !!python/tuple ['1. Transform operation: Replace the while loop
            with a recursive function call to reduce(squares) where reduction logic
            is implemented in a separate function, utilizing memoization to optimize
            performance', 'Reverse operation: Revert the code back to using a traditional
            while loop and remove the separate reduction function.']
        middle_state:
          description: '**Fractal Dimension Estimation**

            ===


            Given an array of integers representing the length and width of squares
            in a recursive fractal pattern,

            estimate the fractal dimension using the Box Counting method.


            The fractal is generated by recursively splitting each square into four
            smaller squares with half the side length.

            The number of squares at each level of recursion forms a sequence that
            can be used to estimate the fractal dimension.


            **Example:**

            Input: [1, 2, 4, 8]

            Output: 2.0

            '
          code: "def main(squares):\n    memo = {}\n    n = len(squares)\n    levels\
            \ = 0\n    def reduce(squares):\n        if (squares, ) in memo:\n   \
            \         return memo[(squares, )]\n        result = float('inf')\n  \
            \      for i in range(2**len(squares)):\n            temp_squares = []\n\
            \            for j in range(len(squares)):\n                if (i & (1\
            \ << j)) > 0:\n                    temp_squares.append(squares[j])\n \
            \           temp_result = levels + 1\n            for k in range(len(temp_squares)\
            \ - 1):\n                temp_result += reduce([temp_squares[k], temp_squares[k+1]])\n\
            \            result = min(result, temp_result)\n        memo[(squares,\
            \ )] = result\n        return result\n    return reduce(squares)\n\ndef\
            \ reduce(squares):\n    if (squares, ) in memo:\n        return memo[(squares,\
            \ )]\n    result = float('inf')\n    for i in range(2**len(squares)):\n\
            \        temp_squares = []\n        for j in range(len(squares)):\n  \
            \          if (i & (1 << j)) > 0:\n                temp_squares.append(squares[j])\n\
            \        if len(temp_squares) == 1:\n            result = min(result,\
            \ levels + 1)\n        else:\n            temp_result = levels + 1\n \
            \           for k in range(len(temp_squares) - 1):\n                temp_result\
            \ += reduce([temp_squares[k], temp_squares[k+1]])\n            result\
            \ = min(result, temp_result)\n    memo[(squares, )] = result\n    return\
            \ result"
          programming_language: python3
          inputs: *id002
          exec_results: *id003
        parent: *id005
        children: []
      - !!python/object:llmcheck.nodes.node.Node
        content:
          description: '**Fractal Dimension Estimation**

            ===


            Given an array of integers representing the length and width of squares
            in a recursive fractal pattern,

            estimate the fractal dimension using the Box Counting method.


            The fractal is generated by recursively splitting each square into four
            smaller squares with half the side length.

            The number of squares at each level of recursion forms a sequence that
            can be used to estimate the fractal dimension.


            **Example:**

            Input: [1, 2, 4, 8]

            Output: 2.0

            '
          code: "def main(squares):\n    n = len(squares)\n    levels = 0\n    while\
            \ (n > 1 and squares[0] == squares[-1]):\n        squares = [s // 2 for\
            \ s in squares]\n        n //= 2\n        levels += 1\n    if n != 1:\n\
            \        return -1.0\n    else:\n        result = float('inf')\n     \
            \   for i in range(n):\n            for j in range(i, n):\n          \
            \      left = 0\n                for k in range(i, j):\n             \
            \       left += sum(squares[i:k])\n                right = 0\n       \
            \         for k in range(j, n):\n                    right += sum(squares[k:j+1])\n\
            \                temp_result = min(left + right + (squares[j] if i !=\
            \ j else squares[j]), result)\n                result = min(result, temp_result)\n\
            \        return result + levels + 1\n\ndef sum(squares):\n    n = len(squares)\n\
            \    def helper(i, j):\n        if i == j:\n            return squares[i]\n\
            \        result = float('inf')\n        for k in range(i, j+1):\n    \
            \        left = helper(i, k-1) if i < k else 0\n            right = helper(k,\
            \ j-1) if k <= j else 0\n            result = min(result, left + right)\n\
            \        return result\n    return helper(0, n-1)"
          programming_language: python3
          inputs: *id002
          exec_results: *id003
        operation: !!python/tuple ['2. Transform operation: Implement dynamic programming
            by introducing an auxiliary "reduction_table" dictionary that stores intermediate
            results of sub-problems, accessed via the squares list as keys, allowing
            for efficient caching of computations', 'Reverse operation: Eliminate
            the "reduction_table" dictionary and revert to computing each value directly
            within the while loop.']
        middle_state:
          description: '**Fractal Dimension Estimation**

            ===


            Given an array of integers representing the length and width of squares
            in a recursive fractal pattern,

            estimate the fractal dimension using the Box Counting method.


            The fractal is generated by recursively splitting each square into four
            smaller squares with half the side length.

            The number of squares at each level of recursion forms a sequence that
            can be used to estimate the fractal dimension.


            **Example:**

            Input: [1, 2, 4, 8]

            Output: 2.0

            '
          code: "def main(squares):\n    reduction_table = {}\n    n = len(squares)\n\
            \    levels = 0\n    while (n > 1 and squares[0] == squares[-1]):\n  \
            \      squares = [s // 2 for s in squares]\n        n //= 2\n        levels\
            \ += 1\n    if n != 1:\n        return -1.0\n    else:\n        result\
            \ = float('inf')\n        for i in range(n):\n            for j in range(i,\
            \ n):\n                key = (i, j)\n                if key not in reduction_table:\n\
            \                    left = 0\n                    for k in range(i, j):\n\
            \                        left += sum(squares[i:k])\n                 \
            \   right = 0\n                    for k in range(j, n):\n           \
            \             right += sum(squares[k:j+1])\n                    temp_result\
            \ = min(left + right + (squares[j] if i != j else squares[j]), result)\n\
            \                    reduction_table[key] = temp_result\n            \
            \    else:\n                    temp_result = reduction_table[key]\n \
            \               result = min(result, temp_result)\n        return result\
            \ + levels + 1\n\ndef sum(squares):\n    n = len(squares)\n    def helper(i,\
            \ j):\n        if (i, j) in reduction_table:\n            return reduction_table[(i,\
            \ j)]\n        if i == j:\n            return squares[i]\n        result\
            \ = float('inf')\n        for k in range(i, j+1):\n            left =\
            \ sum(squares[i:k])\n            right = sum(squares[k:j+1])\n       \
            \     result = min(result, left + right)\n        reduction_table[(i,\
            \ j)] = result\n        return result\n    return helper(0, n-1)"
          programming_language: python3
          inputs: *id002
          exec_results: *id003
        parent: *id005
        children: []
    - &id006 !!python/object:llmcheck.nodes.node.Node
      content:
        description: '**Fractal Dimension Estimation**

          ===


          Given an array of integers representing the length and width of squares
          in a recursive fractal pattern,

          estimate the fractal dimension using the Box Counting method.


          The fractal is generated by recursively splitting each square into four
          smaller squares with half the side length.

          The number of squares at each level of recursion forms a sequence that can
          be used to estimate the fractal dimension.


          **Example:**

          Input: [1, 2, 4, 8]

          Output: 2.0

          '
        code: "def main(squares):\n    def dp(i, j):\n        if i == j:\n       \
          \     return 0\n        result = float('inf')\n        for k in range(i,\
          \ j+1):\n            result = min(result, dp(i, k) + dp(k+1, j))\n     \
          \   return result\n    n = len(squares)\n    levels = 0\n    while (n >\
          \ 1 and squares[0] == squares[-1]):\n        new_squares = [s // 2 for s\
          \ in squares]\n        levels += 1\n        n //= 2\n        if n != 1:\n\
          \            return -1.0\n        else:\n            return levels + 1"
        programming_language: python3
        inputs: *id002
        exec_results: *id003
      operation: !!python/tuple ['2. Transform operation: Implement dynamic programming
          by introducing an auxiliary "reduction_table" dictionary that stores intermediate
          results of sub-problems, accessed via the squares list as keys, allowing
          for efficient caching of computations', 'Reverse operation: Eliminate the
          "reduction_table" dictionary and revert to computing each value directly
          within the while loop.']
      middle_state:
        description: '**Fractal Dimension Estimation**

          ===


          Given an array of integers representing the length and width of squares
          in a recursive fractal pattern,

          estimate the fractal dimension using the Box Counting method.


          The fractal is generated by recursively splitting each square into four
          smaller squares with half the side length.

          The number of squares at each level of recursion forms a sequence that can
          be used to estimate the fractal dimension.


          **Example:**

          Input: [1, 2, 4, 8]

          Output: 2.0

          '
        code: "def main(squares):\n    reduction_table = {}\n    def dp(i, j):\n \
          \       if (i, j) in reduction_table:\n            return reduction_table[(i,\
          \ j)]\n        if i == j:\n            reduction_table[(i, j)] = 0\n   \
          \         return 0\n        result = float('inf')\n        for k in range(i,\
          \ j+1):\n            result = min(result, dp(i, k) + dp(k+1, j))\n     \
          \   reduction_table[(i, j)] = result\n        return result\n    n = len(squares)\n\
          \    levels = 0\n    while (n > 1 and squares[0] == squares[-1]):\n    \
          \    if (0, n-1) not in reduction_table:\n            reduction_table[(0,\
          \ n-1)] = dp(0, n-1)\n        new_squares = [s // 2 for s in squares]\n\
          \        levels += 1\n        n //= 2\n    if n != 1:\n        return -1.0\n\
          \    else:\n        return levels + 1"
        programming_language: python3
        inputs: *id002
        exec_results: *id003
      parent: *id004
      children:
      - !!python/object:llmcheck.nodes.node.Node
        content:
          description: '**Fractal Dimension Estimation**

            ===


            Given an array of integers representing the length and width of squares
            in a recursive fractal pattern,

            estimate the fractal dimension using the Box Counting method.


            The fractal is generated by recursively splitting each square into four
            smaller squares with half the side length.

            The number of squares at each level of recursion forms a sequence that
            can be used to estimate the fractal dimension.


            **Example:**

            Input: [1, 2, 4, 8]

            Output: 2.0

            '
          code: "```python\ndef main(squares):\n    memo = {}\n    n = len(squares)\n\
            \n    def dfs(i, j):\n        if (i, j) in memo:\n            return memo[(i,\
            \ j)]\n        \n        if i == j:\n            return 0\n        \n\
            \        result = float('inf')\n        for k in range(i, j+1):\n    \
            \        result = min(result, dfs(i, k) + dfs(k+1, j))\n        \n   \
            \     memo[(i, j)] = result\n        return result\n\n    levels = dfs(0,\
            \ n-1)\n    if levels >= float('inf'):\n        return -1.0\n    else:\n\
            \        return levels + 1\n\nreturn main(squares)"
          programming_language: python3
          inputs: *id002
          exec_results: *id003
        operation: !!python/tuple ['1. Transform operation: Replace the while loop
            with a recursive function call to reduce(squares) where reduction logic
            is implemented in a separate function, utilizing memoization to optimize
            performance', 'Reverse operation: Revert the code back to using a traditional
            while loop and remove the separate reduction function.']
        middle_state:
          description: '**Fractal Dimension Estimation**

            ===


            Given an array of integers representing the length and width of squares
            in a recursive fractal pattern,

            estimate the fractal dimension using the Box Counting method.


            The fractal is generated by recursively splitting each square into four
            smaller squares with half the side length.

            The number of squares at each level of recursion forms a sequence that
            can be used to estimate the fractal dimension.


            **Example:**

            Input: [1, 2, 4, 8]

            Output: 2.0

            '
          code: "```python\ndef main(squares):\n    memo = {}\n\n    def reduce(squares,\
            \ i, j):\n        if (i, j) in memo:\n            return memo[(i, j)]\n\
            \        \n        if i == j:\n            return 0\n        \n      \
            \  result = float('inf')\n        for k in range(i, j+1):\n          \
            \  result = min(result, reduce(squares, i, k) + reduce(squares, k+1, j))\n\
            \        \n        memo[(i, j)] = result\n        return result\n\n  \
            \  def dfs(squares):\n        n = len(squares)\n        if n == 1:\n \
            \           return 0\n        \n        new_squares = [s // 2 for s in\
            \ squares]\n        levels = reduce(new_squares, 0, n-1) + 1\n       \
            \ if levels >= float('inf'):\n            return -1.0\n        else:\n\
            \            return levels\n\n    return dfs(squares)"
          programming_language: python3
          inputs: *id002
          exec_results: *id003
        parent: *id006
        children: []
      - !!python/object:llmcheck.nodes.node.Node
        content:
          description: '**Fractal Dimension Estimation**

            ===


            Given an array of integers representing the length and width of squares
            in a recursive fractal pattern,

            estimate the fractal dimension using the Box Counting method.


            The fractal is generated by recursively splitting each square into four
            smaller squares with half the side length.

            The number of squares at each level of recursion forms a sequence that
            can be used to estimate the fractal dimension.


            **Example:**

            Input: [1, 2, 4, 8]

            Output: 2.0

            '
          code: "def main(squares):\n    def dp(i, j):\n        if i == j:\n     \
            \       result = 0\n        else:\n            result = float('inf')\n\
            \            for k in range(i, j+1):\n                result = min(result,\
            \ dp(i, k) + dp(k+1, j))\n        return result\n    n = len(squares)\n\
            \    levels = 0\n    while (n > 1 and squares[0] == squares[-1]):\n  \
            \      new_squares = [s // 2 for s in squares]\n        levels += 1\n\
            \        n //= 2\n        if n != 1:\n            return -1.0\n      \
            \  else:\n            return levels + 1"
          programming_language: python3
          inputs: *id002
          exec_results: *id003
        operation: !!python/tuple ['2. Transform operation: Implement dynamic programming
            by introducing an auxiliary "reduction_table" dictionary that stores intermediate
            results of sub-problems, accessed via the squares list as keys, allowing
            for efficient caching of computations', 'Reverse operation: Eliminate
            the "reduction_table" dictionary and revert to computing each value directly
            within the while loop.']
        middle_state:
          description: '**Fractal Dimension Estimation**

            ===


            Given an array of integers representing the length and width of squares
            in a recursive fractal pattern,

            estimate the fractal dimension using the Box Counting method.


            The fractal is generated by recursively splitting each square into four
            smaller squares with half the side length.

            The number of squares at each level of recursion forms a sequence that
            can be used to estimate the fractal dimension.


            **Example:**

            Input: [1, 2, 4, 8]

            Output: 2.0

            '
          code: "def main(squares):\n    reduction_table = {}\n    def dp(i, j):\n\
            \        key = (i, j)\n        if key in reduction_table:\n          \
            \  return reduction_table[key]\n        if i == j:\n            result\
            \ = 0\n        else:\n            result = float('inf')\n            for\
            \ k in range(i, j+1):\n                result = min(result, dp(i, k) +\
            \ dp(k+1, j))\n        reduction_table[key] = result\n        return result\n\
            \    n = len(squares)\n    levels = 0\n    while (n > 1 and squares[0]\
            \ == squares[-1]):\n        new_squares = [s // 2 for s in squares]\n\
            \        levels += 1\n        n //= 2\n        if n != 1:\n          \
            \  return -1.0\n        else:\n            return levels + 1"
          programming_language: python3
          inputs: *id002
          exec_results: *id003
        parent: *id006
        children: []
