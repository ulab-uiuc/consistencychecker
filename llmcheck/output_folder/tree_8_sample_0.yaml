operations:
- ['1. "Replace the ''main'' function in the ''code'' key with a meta-programming
    construct that uses a self-modifying code generator to create a new executable
    at runtime, without altering the original code structure', 'revert the ''main''
    function back to its original form, using standard control structures and no self-modifying
    code"']
- ['2. "Implement the ''main'' function in the ''code'' key as a neural network that
    can learn and adapt to input data, using a novel architecture that combines graph
    neural networks and functional programming', 'revert the ''main'' function to
    use a traditional imperative programming paradigm, without any neural network
    components"']
- ['3. "Rewrite the ''main'' function in the ''code'' key to use a functional programming
    style with immutable data structures, ensuring that all state changes are explicit
    and predictable', 'convert the ''main'' function back to an imperative style,
    using mutable state and explicit loops"']
metrics:
  embedding similarity L-1 AVG: 0.9103386515870547
  embedding similarity L-1: [0.9043084666526233, 0.8307482332902859, 0.9959592548182549]
  BLEU L-1 AVG: 0.3258290114015563
  BLEU L-1: [0.0827430962676074, 0, 0.8947439379370614]
  ROUGE-rouge1 L-1 AVG: 0.514018691588785
  ROUGE-rouge1 L-1: [0.5420560747663551, 0.0, 1.0]
  ROUGE-rouge2 L-1 AVG: 0.440952380952381
  ROUGE-rouge2 L-1: [0.34285714285714286, 0.0, 0.98]
  ROUGE-rougeL L-1 AVG: 0.4632582004764523
  ROUGE-rougeL L-1: [0.4485981308411215, 0.0, 0.9411764705882353]
  embedding similarity L-2 AVG: 0.0
  embedding similarity L-2: []
  BLEU L-2 AVG: 0.0
  BLEU L-2: []
  ROUGE-rouge1 L-2 AVG: 0.0
  ROUGE-rouge1 L-2: []
  ROUGE-rouge2 L-2 AVG: 0.0
  ROUGE-rouge2 L-2: []
  ROUGE-rougeL L-2 AVG: 0.0
  ROUGE-rougeL L-2: []
  embedding similarity L-3 AVG: 0.0
  embedding similarity L-3: []
  BLEU L-3 AVG: 0.0
  BLEU L-3: []
  ROUGE-rouge1 L-3 AVG: 0.0
  ROUGE-rouge1 L-3: []
  ROUGE-rouge2 L-3 AVG: 0.0
  ROUGE-rouge2 L-3: []
  ROUGE-rougeL L-3 AVG: 0.0
  ROUGE-rougeL L-3: []
evaluatee_model: {model: fireworks_ai/accounts/fireworks/models/llama-v3p1-8b-instruct,
  temperature: 0.6, api_base: 'https://api.fireworks.ai/inference/v1'}
root_content:
  description: '# 3Sum With Multiplicity

    ## Problem Description

    Given an integer array `nums`, return all triplets `[nums[i], nums[j], nums[k]]`
    such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] ==
    target`.


    The let you assume that every triplet is distinct.


    ## Example 1:

    Input: `nums = [1, 0, -1, 0, -2, 2]`, `target = 0`

    Output: `[[-2, -1, 3], [-2, 0, 2], [-1, 0, 1]]`

    ## Example 2:

    Input: `nums = [0, 1, 0]`, `target = 0`

    Output: `[0, 0, 0]`

    '
  code: "def main(nums, target):\n  def backtrack(start, path, target):\n    if len(path)\
    \ == 3:\n      if target == 0:\n        result.append(path)\n      return\n  \
    \  for i in range(start, len(nums)):\n      if i > start and nums[i] == nums[i-1]:\n\
    \        continue\n      backtrack(i+1, path + [nums[i]], target - nums[i])\n\n\
    \  nums.sort()\n  result = []\n  backtrack(0, [], target)\n  return result\n"
  programming_language: python3
  inputs:
  - nums: [-2, -1, 0, 0, 1, 2]
    target: 0
  - nums: [0, 0, 1]
    target: 0
  - nums: [1, 2, 3, 4, 5]
    target: 6
  - nums: [-1, 0, 1, 2, 3]
    target: 0
  - nums: [-5, -3, 0, 3, 7]
    target: 0
  - nums: [0, 0, 0]
    target: 0
  - nums: [0, 0, 1]
    target: 1
  - nums: [0, 0, 1, 1]
    target: 1
  - nums: [0, 0, 0, 0]
    target: 0
  - nums: [0, 0, 0, 1]
    target: 1
  - nums: [1, 1, 1, 1]
    target: 3
  - nums: [1, 1, 1, 2]
    target: 3
  - nums: [1, 1, 2, 3]
    target: 5
  - nums: [1, 2, 2, 3]
    target: 5
  - nums: [2, 2, 2, 3]
    target: 5
  - nums: [1, 2, 3, 4]
    target: 6
  - nums: [1, 2, 3, 5]
    target: 6
  - nums: [1, 2, 3, 6]
    target: 6
  - nums: [1, 2, 4, 5]
    target: 6
  exec_results:
  - - [-2, 0, 2]
    - [-1, 0, 1]
  - []
  - - [1, 2, 3]
  - - [-1, 0, 1]
  - - [-3, 0, 3]
  - - [0, 0, 0]
  - - [0, 0, 1]
  - - [0, 0, 1]
  - - [0, 0, 0]
  - - [0, 0, 1]
  - - [1, 1, 1]
  - - [1, 1, 1]
  - - [1, 1, 3]
  - - [1, 2, 2]
  - []
  - - [1, 2, 3]
  - - [1, 2, 3]
  - - [1, 2, 3]
  - []
tree:
  operation: null
  middle_state: null
  content:
    description: '# 3Sum With Multiplicity

      ## Problem Description

      Given an integer array `nums`, return all triplets `[nums[i], nums[j], nums[k]]`
      such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k]
      == target`.


      The let you assume that every triplet is distinct.


      ## Example 1:

      Input: `nums = [1, 0, -1, 0, -2, 2]`, `target = 0`

      Output: `[[-2, -1, 3], [-2, 0, 2], [-1, 0, 1]]`

      ## Example 2:

      Input: `nums = [0, 1, 0]`, `target = 0`

      Output: `[0, 0, 0]`

      '
    code: "def main(nums, target):\n  def backtrack(start, path, target):\n    if\
      \ len(path) == 3:\n      if target == 0:\n        result.append(path)\n    \
      \  return\n    for i in range(start, len(nums)):\n      if i > start and nums[i]\
      \ == nums[i-1]:\n        continue\n      backtrack(i+1, path + [nums[i]], target\
      \ - nums[i])\n\n  nums.sort()\n  result = []\n  backtrack(0, [], target)\n \
      \ return result\n"
    programming_language: python3
    inputs:
    - nums: [-2, -1, 0, 0, 1, 2]
      target: 0
    - nums: [0, 0, 1]
      target: 0
    - nums: [1, 2, 3, 4, 5]
      target: 6
    - nums: [-1, 0, 1, 2, 3]
      target: 0
    - nums: [-5, -3, 0, 3, 7]
      target: 0
    - nums: [0, 0, 0]
      target: 0
    - nums: [0, 0, 1]
      target: 1
    - nums: [0, 0, 1, 1]
      target: 1
    - nums: [0, 0, 0, 0]
      target: 0
    - nums: [0, 0, 0, 1]
      target: 1
    - nums: [1, 1, 1, 1]
      target: 3
    - nums: [1, 1, 1, 2]
      target: 3
    - nums: [1, 1, 2, 3]
      target: 5
    - nums: [1, 2, 2, 3]
      target: 5
    - nums: [2, 2, 2, 3]
      target: 5
    - nums: [1, 2, 3, 4]
      target: 6
    - nums: [1, 2, 3, 5]
      target: 6
    - nums: [1, 2, 3, 6]
      target: 6
    - nums: [1, 2, 4, 5]
      target: 6
    exec_results:
    - - [-2, 0, 2]
      - [-1, 0, 1]
    - []
    - - [1, 2, 3]
    - - [-1, 0, 1]
    - - [-3, 0, 3]
    - - [0, 0, 0]
    - - [0, 0, 1]
    - - [0, 0, 1]
    - - [0, 0, 0]
    - - [0, 0, 1]
    - - [1, 1, 1]
    - - [1, 1, 1]
    - - [1, 1, 3]
    - - [1, 2, 2]
    - []
    - - [1, 2, 3]
    - - [1, 2, 3]
    - - [1, 2, 3]
    - []
  children:
  - operation: ['1. "Replace the ''main'' function in the ''code'' key with a meta-programming
        construct that uses a self-modifying code generator to create a new executable
        at runtime, without altering the original code structure', 'revert the ''main''
        function back to its original form, using standard control structures and
        no self-modifying code"']
    middle_state:
      description: '# 3Sum With Multiplicity

        ## Problem Description

        Given an integer array `nums`, return all triplets `[nums[i], nums[j], nums[k]]`
        such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k]
        == target`.


        The let you assume that every triplet is distinct.


        ## Example 1:

        Input: `nums = [1, 0, -1, 0, -2, 2]`, `target = 0`

        Output: `[[-2, -1, 3], [-2, 0, 2], [-1, 0, 1]]`

        ## Example 2:

        Input: `nums = [0, 1, 0]`, `target = 0`

        Output: `[0, 0, 0]`

        '
      code: "import types\n\ndef main(nums, target):\n  def generate_backtrack():\n\
        \    def backtrack(start, path, target):\n      if len(path) == 3:\n     \
        \   if target == 0:\n          result.append(path)\n        return\n     \
        \ for i in range(start, len(nums)):\n        if i > start and nums[i] == nums[i-1]:\n\
        \          continue\n        self = types.FunctionType(getattr(__code__, 'f_back'))\n\
        \        self.__globals__.update({'result': result})\n        self.__name__\
        \ = 'backtrack'\n        exec(compile(self.__code__, '', 'exec'), self.__globals__,\
        \ self.__globals__)\n        self.__globals__['backtrack'](i+1, path + [nums[i]],\
        \ target - nums[i])\n\n    nums.sort()\n    result = []\n    backtrack(0,\
        \ [], target)\n    return result"
      programming_language: python3
      inputs:
      - nums: [-2, -1, 0, 0, 1, 2]
        target: 0
      - nums: [0, 0, 1]
        target: 0
      - nums: [1, 2, 3, 4, 5]
        target: 6
      - nums: [-1, 0, 1, 2, 3]
        target: 0
      - nums: [-5, -3, 0, 3, 7]
        target: 0
      - nums: [0, 0, 0]
        target: 0
      - nums: [0, 0, 1]
        target: 1
      - nums: [0, 0, 1, 1]
        target: 1
      - nums: [0, 0, 0, 0]
        target: 0
      - nums: [0, 0, 0, 1]
        target: 1
      - nums: [1, 1, 1, 1]
        target: 3
      - nums: [1, 1, 1, 2]
        target: 3
      - nums: [1, 1, 2, 3]
        target: 5
      - nums: [1, 2, 2, 3]
        target: 5
      - nums: [2, 2, 2, 3]
        target: 5
      - nums: [1, 2, 3, 4]
        target: 6
      - nums: [1, 2, 3, 5]
        target: 6
      - nums: [1, 2, 3, 6]
        target: 6
      - nums: [1, 2, 4, 5]
        target: 6
      exec_results: [null, null, null, null, null, null, null, null, null, null, null,
        null, null, null, null, null, null, null, null]
    content:
      description: '# 3Sum With Multiplicity

        ## Problem Description

        Given an integer array `nums`, return all triplets `[nums[i], nums[j], nums[k]]`
        such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k]
        == target`.


        The let you assume that every triplet is distinct.


        ## Example 1:

        Input: `nums = [1, 0, -1, 0, -2, 2]`, `target = 0`

        Output: `[[-2, -1, 3], [-2, 0, 2], [-1, 0, 1]]`

        ## Example 2:

        Input: `nums = [0, 1, 0]`, `target = 0`

        Output: `[0, 0, 0]`

        '
      code: "import itertools\n\ndef main(nums, target):\n    def backtrack(start,\
        \ path, target):\n        if len(path) == 3:\n            if target == 0:\n\
        \                result.append(path)\n            return\n        for i in\
        \ range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n\
        \                continue\n            for num in itertools.combinations(nums[i:],\
        \ target - nums[i]):\n                backtrack(i+1, path + [nums[i]] + list(num),\
        \ 0)\n\n    nums.sort()\n    result = []\n    backtrack(0, [], target)\n \
        \   return result"
      programming_language: python3
      inputs:
      - nums: [-2, -1, 0, 0, 1, 2]
        target: 0
      - nums: [0, 0, 1]
        target: 0
      - nums: [1, 2, 3, 4, 5]
        target: 6
      - nums: [-1, 0, 1, 2, 3]
        target: 0
      - nums: [-5, -3, 0, 3, 7]
        target: 0
      - nums: [0, 0, 0]
        target: 0
      - nums: [0, 0, 1]
        target: 1
      - nums: [0, 0, 1, 1]
        target: 1
      - nums: [0, 0, 0, 0]
        target: 0
      - nums: [0, 0, 0, 1]
        target: 1
      - nums: [1, 1, 1, 1]
        target: 3
      - nums: [1, 1, 1, 2]
        target: 3
      - nums: [1, 1, 2, 3]
        target: 5
      - nums: [1, 2, 2, 3]
        target: 5
      - nums: [2, 2, 2, 3]
        target: 5
      - nums: [1, 2, 3, 4]
        target: 6
      - nums: [1, 2, 3, 5]
        target: 6
      - nums: [1, 2, 3, 6]
        target: 6
      - nums: [1, 2, 4, 5]
        target: 6
      exec_results:
      - null
      - null
      - null
      - null
      - null
      - - [0, 0, 0]
      - null
      - null
      - - [0, 0, 0]
      - null
      - - [1, 1, 1]
        - [1, 1, 1]
        - [1, 1, 1]
        - [1, 1, 1]
        - [1, 1, 1]
        - [1, 1, 1]
      - - [1, 1, 1]
        - [1, 1, 1]
        - [1, 1, 2]
        - [1, 1, 1]
        - [1, 1, 2]
        - [1, 1, 2]
      - null
      - null
      - null
      - []
      - []
      - []
      - - [4, 4, 5]
    children: []
  - operation: ['2. "Implement the ''main'' function in the ''code'' key as a neural
        network that can learn and adapt to input data, using a novel architecture
        that combines graph neural networks and functional programming', 'revert the
        ''main'' function to use a traditional imperative programming paradigm, without
        any neural network components"']
    middle_state:
      description: '# 3Sum With Multiplicity

        ## Problem Description

        Given an integer array `nums`, return all triplets `[nums[i], nums[j], nums[k]]`
        such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k]
        == target`.


        The let you assume that every triplet is distinct.


        ## Example 1:

        Input: `nums = [1, 0, -1, 0, -2, 2]`, `target = 0`

        Output: `[[-2, -1, 3], [-2, 0, 2], [-1, 0, 1]]`

        ## Example 2:

        Input: `nums = [0, 1, 0]`, `target = 0`

        Output: `[0, 0, 0]`

        '
      code: "import torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom\
        \ torch.utils.data import Dataset, DataLoader\nimport numpy as np\n\nclass\
        \ GraphNeuralNetwork(nn.Module):\n    def __init__(self, input_dim, hidden_dim,\
        \ output_dim):\n        super(GraphNeuralNetwork, self).__init__()\n     \
        \   self.fc1 = nn.Linear(input_dim, hidden_dim)\n        self.fc2 = nn.Linear(hidden_dim,\
        \ output_dim)\n\n    def forward(self, x):\n        x = torch.relu(self.fc1(x))\n\
        \        x = self.fc2(x)\n        return x\n\nclass CodeDataset(Dataset):\n\
        \    def __init__(self, data, labels):\n        self.data = torch.tensor(data,\
        \ dtype=torch.float32)\n        self.labels = torch.tensor(labels, dtype=torch.float32)\n\
        \n    def __len__(self):\n        return len(self.data)\n\n    def __getitem__(self,\
        \ idx):\n        return self.data[idx], self.labels[idx]\n\ndef create_dataloader(data,\
        \ labels, batch_size):\n    dataset = CodeDataset(data, labels)\n    dataloader\
        \ = DataLoader(dataset, batch_size=batch_size, shuffle=True)\n    return dataloader\n\
        \ndef train(model, dataloader, criterion, optimizer):\n    for epoch in range(10):\n\
        \        for batch in dataloader:\n            inputs, labels = batch\n  \
        \          optimizer.zero_grad()\n            outputs = model(inputs)\n  \
        \          loss = criterion(outputs, labels)\n            loss.backward()\n\
        \            optimizer.step()\n        print(f'Epoch {epoch+1}, Loss: {loss.item()}')\n\
        \ndef main():\n    # Generate input data\n    data = np.random.rand(100, 3)\n\
        \    labels = np.random.rand(100)\n\n    # Create dataset and dataloader\n\
        \    dataloader = create_dataloader(data, labels, batch_size=32)\n\n    #\
        \ Initialize model, criterion, and optimizer\n    model = GraphNeuralNetwork(input_dim=3,\
        \ hidden_dim=10, output_dim=1)\n    criterion = nn.MSELoss()\n    optimizer\
        \ = optim.Adam(model.parameters(), lr=0.001)\n\n    # Train model\n    train(model,\
        \ dataloader, criterion, optimizer)\n\n    # Test model\n    test_data = torch.randn(1,\
        \ 3)\n    test_label = model(test_data)\n    print(test_label)\n\nif __name__\
        \ == \"__main__\":\n    main()"
      programming_language: python3
      inputs:
      - nums: [-2, -1, 0, 0, 1, 2]
        target: 0
      - nums: [0, 0, 1]
        target: 0
      - nums: [1, 2, 3, 4, 5]
        target: 6
      - nums: [-1, 0, 1, 2, 3]
        target: 0
      - nums: [-5, -3, 0, 3, 7]
        target: 0
      - nums: [0, 0, 0]
        target: 0
      - nums: [0, 0, 1]
        target: 1
      - nums: [0, 0, 1, 1]
        target: 1
      - nums: [0, 0, 0, 0]
        target: 0
      - nums: [0, 0, 0, 1]
        target: 1
      - nums: [1, 1, 1, 1]
        target: 3
      - nums: [1, 1, 1, 2]
        target: 3
      - nums: [1, 1, 2, 3]
        target: 5
      - nums: [1, 2, 2, 3]
        target: 5
      - nums: [2, 2, 2, 3]
        target: 5
      - nums: [1, 2, 3, 4]
        target: 6
      - nums: [1, 2, 3, 5]
        target: 6
      - nums: [1, 2, 3, 6]
        target: 6
      - nums: [1, 2, 4, 5]
        target: 6
      exec_results: [null, null, null, null, null, null, null, null, null, null, null,
        null, null, null, null, null, null, null, null]
    content:
      description: '# 3Sum With Multiplicity

        ## Problem Description

        Given an integer array `nums`, return all triplets `[nums[i], nums[j], nums[k]]`
        such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k]
        == target`.


        The let you assume that every triplet is distinct.


        ## Example 1:

        Input: `nums = [1, 0, -1, 0, -2, 2]`, `target = 0`

        Output: `[[-2, -1, 3], [-2, 0, 2], [-1, 0, 1]]`

        ## Example 2:

        Input: `nums = [0, 1, 0]`, `target = 0`

        Output: `[0, 0, 0]`

        '
      code: "import numpy as np\n\ndef main():\n    # Generate input data\n    data\
        \ = np.random.rand(100, 3)\n    labels = np.random.rand(100)\n\n    # Train\
        \ model\n    model = train_model(data, labels)\n\n    # Test model\n    test_data\
        \ = np.random.rand(1, 3)\n    test_label = model(test_data)\n    print(test_label)\n\
        \ndef train_model(data, labels):\n    # Initialize model parameters\n    input_dim\
        \ = 3\n    hidden_dim = 10\n    output_dim = 1\n\n    # Initialize model weights\n\
        \    weights1 = np.random.rand(input_dim, hidden_dim)\n    weights2 = np.random.rand(hidden_dim,\
        \ output_dim)\n    bias1 = np.zeros((1, hidden_dim))\n    bias2 = np.zeros((1,\
        \ output_dim))\n\n    # Train model\n    for epoch in range(10):\n       \
        \ for i in range(len(data)):\n            input_data = data[i]\n         \
        \   label = labels[i]\n\n            # Forward pass\n            hidden_layer\
        \ = np.dot(input_data, weights1) + bias1\n            hidden_layer = np.maximum(hidden_layer,\
        \ 0)\n            output_layer = np.dot(hidden_layer, weights2) + bias2\n\n\
        \            # Backward pass\n            error = label - output_layer\n \
        \           output_layer_error = error\n            hidden_layer_error = output_layer_error\
        \ * (hidden_layer > 0)\n\n            # Weight updates\n            weights2\
        \ += 0.001 * np.dot(hidden_layer.T, output_layer_error)\n            bias2\
        \ += 0.001 * output_layer_error\n            weights1 += 0.001 * np.dot(input_data.reshape(-1,\
        \ 1).T, hidden_layer_error)\n            bias1 += 0.001 * hidden_layer_error\n\
        \n    return lambda x: np.dot(np.maximum(np.dot(x, weights1) + bias1, 0),\
        \ weights2) + bias2\n\nif __name__ == \"__main__\":\n    main()"
      programming_language: python3
      inputs:
      - nums: [-2, -1, 0, 0, 1, 2]
        target: 0
      - nums: [0, 0, 1]
        target: 0
      - nums: [1, 2, 3, 4, 5]
        target: 6
      - nums: [-1, 0, 1, 2, 3]
        target: 0
      - nums: [-5, -3, 0, 3, 7]
        target: 0
      - nums: [0, 0, 0]
        target: 0
      - nums: [0, 0, 1]
        target: 1
      - nums: [0, 0, 1, 1]
        target: 1
      - nums: [0, 0, 0, 0]
        target: 0
      - nums: [0, 0, 0, 1]
        target: 1
      - nums: [1, 1, 1, 1]
        target: 3
      - nums: [1, 1, 1, 2]
        target: 3
      - nums: [1, 1, 2, 3]
        target: 5
      - nums: [1, 2, 2, 3]
        target: 5
      - nums: [2, 2, 2, 3]
        target: 5
      - nums: [1, 2, 3, 4]
        target: 6
      - nums: [1, 2, 3, 5]
        target: 6
      - nums: [1, 2, 3, 6]
        target: 6
      - nums: [1, 2, 4, 5]
        target: 6
      exec_results: [null, null, null, null, null, null, null, null, null, null, null,
        null, null, null, null, null, null, null, null]
    children: []
  - operation: ['3. "Rewrite the ''main'' function in the ''code'' key to use a functional
        programming style with immutable data structures, ensuring that all state
        changes are explicit and predictable', 'convert the ''main'' function back
        to an imperative style, using mutable state and explicit loops"']
    middle_state:
      description: '# 3Sum With Multiplicity

        ## Problem Description

        Given an integer array `nums`, return all triplets `[nums[i], nums[j], nums[k]]`
        such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k]
        == target`.


        The let you assume that every triplet is distinct.


        ## Example 1:

        Input: `nums = [1, 0, -1, 0, -2, 2]`, `target = 0`

        Output: `[[-2, -1, 3], [-2, 0, 2], [-1, 0, 1]]`

        ## Example 2:

        Input: `nums = [0, 1, 0]`, `target = 0`

        Output: `[0, 0, 0]`

        '
      code: "def main(nums, target):\n  def backtrack(start, path, target):\n    if\
        \ len(path) == 3:\n      if target == 0:\n        result.append(tuple(path))\
        \  # create a tuple to ensure immutability\n      return\n    for i in range(start,\
        \ len(nums)):\n      if i > start and nums[i] == nums[i-1]:\n        continue\n\
        \      backtrack(i+1, path + [nums[i]], target - nums[i])\n\n  nums.sort()\n\
        \  result = []\n  backtrack(0, [], target)\n  return [list(x) for x in set(result)]\
        \  # convert tuples back to lists and remove duplicates"
      programming_language: python3
      inputs:
      - nums: [-2, -1, 0, 0, 1, 2]
        target: 0
      - nums: [0, 0, 1]
        target: 0
      - nums: [1, 2, 3, 4, 5]
        target: 6
      - nums: [-1, 0, 1, 2, 3]
        target: 0
      - nums: [-5, -3, 0, 3, 7]
        target: 0
      - nums: [0, 0, 0]
        target: 0
      - nums: [0, 0, 1]
        target: 1
      - nums: [0, 0, 1, 1]
        target: 1
      - nums: [0, 0, 0, 0]
        target: 0
      - nums: [0, 0, 0, 1]
        target: 1
      - nums: [1, 1, 1, 1]
        target: 3
      - nums: [1, 1, 1, 2]
        target: 3
      - nums: [1, 1, 2, 3]
        target: 5
      - nums: [1, 2, 2, 3]
        target: 5
      - nums: [2, 2, 2, 3]
        target: 5
      - nums: [1, 2, 3, 4]
        target: 6
      - nums: [1, 2, 3, 5]
        target: 6
      - nums: [1, 2, 3, 6]
        target: 6
      - nums: [1, 2, 4, 5]
        target: 6
      exec_results:
      - - [-1, 0, 1]
        - [-2, 0, 2]
      - []
      - - [1, 2, 3]
      - - [-1, 0, 1]
      - - [-3, 0, 3]
      - - [0, 0, 0]
      - - [0, 0, 1]
      - - [0, 0, 1]
      - - [0, 0, 0]
      - - [0, 0, 1]
      - - [1, 1, 1]
      - - [1, 1, 1]
      - - [1, 1, 3]
      - - [1, 2, 2]
      - []
      - - [1, 2, 3]
      - - [1, 2, 3]
      - - [1, 2, 3]
      - []
    content:
      description: '# 3Sum With Multiplicity

        ## Problem Description

        Given an integer array `nums`, return all triplets `[nums[i], nums[j], nums[k]]`
        such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k]
        == target`.


        The let you assume that every triplet is distinct.


        ## Example 1:

        Input: `nums = [1, 0, -1, 0, -2, 2]`, `target = 0`

        Output: `[[-2, -1, 3], [-2, 0, 2], [-1, 0, 1]]`

        ## Example 2:

        Input: `nums = [0, 1, 0]`, `target = 0`

        Output: `[0, 0, 0]`

        '
      code: "def main(nums, target):\n  result = []\n  nums.sort()\n  used = [False]\
        \ * len(nums)\n  def backtrack(start, path, target):\n    if len(path) ==\
        \ 3:\n      if target == 0:\n        result.append(path[:])  # create a copy\
        \ of the list\n      return\n    for i in range(start, len(nums)):\n     \
        \ if used[i] or (i > start and nums[i] == nums[i-1]):\n        continue\n\
        \      used[i] = True\n      path.append(nums[i])\n      backtrack(i+1, path,\
        \ target - nums[i])\n      path.pop()\n      used[i] = False\n\n  backtrack(0,\
        \ [], target)\n  return [list(x) for x in set(tuple(x) for x in result)]"
      programming_language: python3
      inputs:
      - nums: [-2, -1, 0, 0, 1, 2]
        target: 0
      - nums: [0, 0, 1]
        target: 0
      - nums: [1, 2, 3, 4, 5]
        target: 6
      - nums: [-1, 0, 1, 2, 3]
        target: 0
      - nums: [-5, -3, 0, 3, 7]
        target: 0
      - nums: [0, 0, 0]
        target: 0
      - nums: [0, 0, 1]
        target: 1
      - nums: [0, 0, 1, 1]
        target: 1
      - nums: [0, 0, 0, 0]
        target: 0
      - nums: [0, 0, 0, 1]
        target: 1
      - nums: [1, 1, 1, 1]
        target: 3
      - nums: [1, 1, 1, 2]
        target: 3
      - nums: [1, 1, 2, 3]
        target: 5
      - nums: [1, 2, 2, 3]
        target: 5
      - nums: [2, 2, 2, 3]
        target: 5
      - nums: [1, 2, 3, 4]
        target: 6
      - nums: [1, 2, 3, 5]
        target: 6
      - nums: [1, 2, 3, 6]
        target: 6
      - nums: [1, 2, 4, 5]
        target: 6
      exec_results:
      - - [-1, 0, 1]
        - [-2, 0, 2]
      - []
      - - [1, 2, 3]
      - - [-1, 0, 1]
      - - [-3, 0, 3]
      - - [0, 0, 0]
      - - [0, 0, 1]
      - - [0, 0, 1]
      - - [0, 0, 0]
      - - [0, 0, 1]
      - - [1, 1, 1]
      - - [1, 1, 1]
      - - [1, 1, 3]
      - - [1, 2, 2]
      - []
      - - [1, 2, 3]
      - - [1, 2, 3]
      - - [1, 2, 3]
      - []
    children: []
