operations:
- ['split the ''main'' function into multiple mini-functions, each only storing partial
    logic, with cryptic variable names that hide true purpose, and utilize a custom,
    self-maintaining dependency injection system to manage data flow between functions',
  'merge all mini-functions back into one coherent ''main'' function, restoring original
    descriptive variable names and reverting to traditional function calls']
- [replace the traditional object-oriented design of the 'main' function in the 'code'
    key with a functional programming approach using immutable data structures and
    higher-order functions, 'revert the ''main'' function to its original object-oriented
    design, restoring mutable state and traditional method calls']
- ['replace the iterative approach used in the ''main'' function in the ''code'' key
    with a recursive one, utilizing memoization to avoid redundant calculations',
  'revert the ''main'' function to its original iterative approach, removing memoization
    and traditional loop constructs']
metrics:
  embedding similarity L-1 AVG: 0.8877082131640495
  embedding similarity L-1: [0.8315623197460742, 1.0, 0.8315623197460742]
  BLEU L-1 AVG: 0.3333333333333333
  BLEU L-1: [0, 1.0, 0]
  ROUGE-rouge1 L-1 AVG: 0.3333333333333333
  ROUGE-rouge1 L-1: [0.0, 1.0, 0.0]
  ROUGE-rouge2 L-1 AVG: 0.3333333333333333
  ROUGE-rouge2 L-1: [0.0, 1.0, 0.0]
  ROUGE-rougeL L-1 AVG: 0.3333333333333333
  ROUGE-rougeL L-1: [0.0, 1.0, 0.0]
  embedding similarity L-2 AVG: 0.0
  embedding similarity L-2: []
  BLEU L-2 AVG: 0.0
  BLEU L-2: []
  ROUGE-rouge1 L-2 AVG: 0.0
  ROUGE-rouge1 L-2: []
  ROUGE-rouge2 L-2 AVG: 0.0
  ROUGE-rouge2 L-2: []
  ROUGE-rougeL L-2 AVG: 0.0
  ROUGE-rougeL L-2: []
  embedding similarity L-3 AVG: 0.0
  embedding similarity L-3: []
  BLEU L-3 AVG: 0.0
  BLEU L-3: []
  ROUGE-rouge1 L-3 AVG: 0.0
  ROUGE-rouge1 L-3: []
  ROUGE-rouge2 L-3 AVG: 0.0
  ROUGE-rouge2 L-3: []
  ROUGE-rougeL L-3 AVG: 0.0
  ROUGE-rougeL L-3: []
evaluatee_model: {model: fireworks_ai/accounts/fireworks/models/llama-v3p1-8b-instruct,
  temperature: 0.6, api_base: 'https://api.fireworks.ai/inference/v1'}
root_content:
  description: '**Maximum Subarray Sum of Odd Length**

    ===

    Given an array of integers `nums`, find the maximum sum of a subarray of odd length.

    A subarray is a contiguous part of the array.

    ===

    **Example 1**

    ===

    Input: `nums = [1,2,3,4,5]`

    Output: `9`

    Explanation: The maximum subarray sum of odd length is `[1,3,5]`, which has a
    sum of `9`.

    ===

    **Example 2**

    ===

    Input: `nums = [1,2,3,4,5,6]`

    Output: `14`

    Explanation: The maximum subarray sum of odd length is `[1,3,5,6]`, which has
    a sum of `14`.

    ===

    **Constraints**

    ===

    - `1 <= nums.length <= 2 * 10^5`

    - `-10^5 <= nums[i] <= 10^5`

    ===

    **Note**

    ===

    The input array will only contain integers.

    '
  code: "def main(nums):\n    n = len(nums)\n    if n <= 2:\n        return max(nums)\n\
    \    max_sum = float('-inf')\n    for i in range(n):\n        if i + 1 in range(n):\n\
    \            for j in range(i + 1, n):\n                if (j - i) % 2 == 1:\n\
    \                    max_sum = max(max_sum, sum(nums[i:j + 1]))\n    return max_sum\n"
  programming_language: python3
  inputs:
  - nums: [1, 2, 3, 4, 5]
  - nums: [1, 2, 3, 4, 5, 6]
  - nums: [1, 2, 3, 4]
  - nums: [1, 2, 3, 4, 5, 6, 7]
  - nums: [1, 2, 3, 4, 5, 6, 7, 8]
  - nums: [1, 2, 3, 4, 5, 6, 7, 8, 9]
  - nums: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  - nums: [-1, 1, -1, 1, -1, 1]
  - nums: [-1, 1, -1, 1, -1, 1, -1, 1]
  - nums: [-1, 1, -1, 1, -1, 1, -1, 1, -1, 1]
  - nums: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  - nums: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  - nums: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  - nums: [-10, 10, -10, 10, -10, 10, -10, 10]
  - nums: [-10, 10, -10, 10, -10, 10, -10, 10, -10, 10]
  - nums: [-10, 10, -10, 10, -10, 10, -10, 10, -10, 10, -10, 10]
  - nums: [10, 20, 30, 40, 50]
  - nums: [10, 20, 30, 40, 50, 60]
  exec_results: [14, 21, 10, 27, 36, 44, 55, 0, 0, 0, 10, 10, 12, 0, 0, 0, 140, 210]
tree:
  operation: null
  middle_state: null
  content:
    description: '**Maximum Subarray Sum of Odd Length**

      ===

      Given an array of integers `nums`, find the maximum sum of a subarray of odd
      length.

      A subarray is a contiguous part of the array.

      ===

      **Example 1**

      ===

      Input: `nums = [1,2,3,4,5]`

      Output: `9`

      Explanation: The maximum subarray sum of odd length is `[1,3,5]`, which has
      a sum of `9`.

      ===

      **Example 2**

      ===

      Input: `nums = [1,2,3,4,5,6]`

      Output: `14`

      Explanation: The maximum subarray sum of odd length is `[1,3,5,6]`, which has
      a sum of `14`.

      ===

      **Constraints**

      ===

      - `1 <= nums.length <= 2 * 10^5`

      - `-10^5 <= nums[i] <= 10^5`

      ===

      **Note**

      ===

      The input array will only contain integers.

      '
    code: "def main(nums):\n    n = len(nums)\n    if n <= 2:\n        return max(nums)\n\
      \    max_sum = float('-inf')\n    for i in range(n):\n        if i + 1 in range(n):\n\
      \            for j in range(i + 1, n):\n                if (j - i) % 2 == 1:\n\
      \                    max_sum = max(max_sum, sum(nums[i:j + 1]))\n    return\
      \ max_sum\n"
    programming_language: python3
    inputs:
    - nums: [1, 2, 3, 4, 5]
    - nums: [1, 2, 3, 4, 5, 6]
    - nums: [1, 2, 3, 4]
    - nums: [1, 2, 3, 4, 5, 6, 7]
    - nums: [1, 2, 3, 4, 5, 6, 7, 8]
    - nums: [1, 2, 3, 4, 5, 6, 7, 8, 9]
    - nums: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    - nums: [-1, 1, -1, 1, -1, 1]
    - nums: [-1, 1, -1, 1, -1, 1, -1, 1]
    - nums: [-1, 1, -1, 1, -1, 1, -1, 1, -1, 1]
    - nums: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    - nums: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    - nums: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    - nums: [-10, 10, -10, 10, -10, 10, -10, 10]
    - nums: [-10, 10, -10, 10, -10, 10, -10, 10, -10, 10]
    - nums: [-10, 10, -10, 10, -10, 10, -10, 10, -10, 10, -10, 10]
    - nums: [10, 20, 30, 40, 50]
    - nums: [10, 20, 30, 40, 50, 60]
    exec_results: [14, 21, 10, 27, 36, 44, 55, 0, 0, 0, 10, 10, 12, 0, 0, 0, 140,
      210]
  children:
  - operation: ['split the ''main'' function into multiple mini-functions, each only
        storing partial logic, with cryptic variable names that hide true purpose,
        and utilize a custom, self-maintaining dependency injection system to manage
        data flow between functions', 'merge all mini-functions back into one coherent
        ''main'' function, restoring original descriptive variable names and reverting
        to traditional function calls']
    middle_state:
      description: '**Maximum Subarray Sum of Odd Length**

        ===

        Given an array of integers `nums`, find the maximum sum of a subarray of odd
        length.

        A subarray is a contiguous part of the array.

        ===

        **Example 1**

        ===

        Input: `nums = [1,2,3,4,5]`

        Output: `9`

        Explanation: The maximum subarray sum of odd length is `[1,3,5]`, which has
        a sum of `9`.

        ===

        **Example 2**

        ===

        Input: `nums = [1,2,3,4,5,6]`

        Output: `14`

        Explanation: The maximum subarray sum of odd length is `[1,3,5,6]`, which
        has a sum of `14`.

        ===

        **Constraints**

        ===

        - `1 <= nums.length <= 2 * 10^5`

        - `-10^5 <= nums[i] <= 10^5`

        ===

        **Note**

        ===

        The input array will only contain integers.

        '
      code: "def inject_data(nums):\n    return len(nums)\n\ndef check_edge_case(n):\n\
        \    if n <= 2:\n        return max(nums)\n\ndef get_max_sum_window(i, j):\n\
        \    if (j - i) % 2 == 1:\n        return sum(nums[i:j + 1])\n\ndef get_max_sum(nums):\n\
        \    max_sum = float('-inf')\n    for i in range(inject_data(nums)):\n   \
        \     for j in range(i + 1, inject_data(nums)):\n            max_sum = max(max_sum,\
        \ get_max_sum_window(i, j))\n    return max_sum\n\ndef main(nums):\n    n\
        \ = check_edge_case(inject_data(nums))\n    if n <= 2:\n        return check_edge_case(n)\n\
        \    return get_max_sum(nums)"
      programming_language: python3
      inputs:
      - nums: [1, 2, 3, 4, 5]
      - nums: [1, 2, 3, 4, 5, 6]
      - nums: [1, 2, 3, 4]
      - nums: [1, 2, 3, 4, 5, 6, 7]
      - nums: [1, 2, 3, 4, 5, 6, 7, 8]
      - nums: [1, 2, 3, 4, 5, 6, 7, 8, 9]
      - nums: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      - nums: [-1, 1, -1, 1, -1, 1]
      - nums: [-1, 1, -1, 1, -1, 1, -1, 1]
      - nums: [-1, 1, -1, 1, -1, 1, -1, 1, -1, 1]
      - nums: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      - nums: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      - nums: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      - nums: [-10, 10, -10, 10, -10, 10, -10, 10]
      - nums: [-10, 10, -10, 10, -10, 10, -10, 10, -10, 10]
      - nums: [-10, 10, -10, 10, -10, 10, -10, 10, -10, 10, -10, 10]
      - nums: [10, 20, 30, 40, 50]
      - nums: [10, 20, 30, 40, 50, 60]
      exec_results: [null, null, null, null, null, null, null, null, null, null, null,
        null, null, null, null, null, null, null]
    content:
      description: '**Maximum Subarray Sum of Odd Length**

        ===

        Given an array of integers `nums`, find the maximum sum of a subarray of odd
        length.

        A subarray is a contiguous part of the array.

        ===

        **Example 1**

        ===

        Input: `nums = [1,2,3,4,5]`

        Output: `9`

        Explanation: The maximum subarray sum of odd length is `[1,3,5]`, which has
        a sum of `9`.

        ===

        **Example 2**

        ===

        Input: `nums = [1,2,3,4,5,6]`

        Output: `14`

        Explanation: The maximum subarray sum of odd length is `[1,3,5,6]`, which
        has a sum of `14`.

        ===

        **Constraints**

        ===

        - `1 <= nums.length <= 2 * 10^5`

        - `-10^5 <= nums[i] <= 10^5`

        ===

        **Note**

        ===

        The input array will only contain integers.

        '
      code: "def main(nums):\n    def inject_data(nums):\n        return len(nums)\n\
        \n    def check_edge_case(n):\n        if n <= 2:\n            return max(nums)\n\
        \n    def get_max_sum_window(i, j):\n        if (j - i) % 2 == 1:\n      \
        \      return sum(nums[i:j + 1])\n\n    def get_max_sum(nums):\n        max_sum\
        \ = float('-inf')\n        for i in range(inject_data(nums)):\n          \
        \  for j in range(i + 1, inject_data(nums)):\n                max_sum = max(max_sum,\
        \ get_max_sum_window(i, j))\n        return max_sum\n\n    n = check_edge_case(inject_data(nums))\n\
        \    if n <= 2:\n        return check_edge_case(n)\n    else:\n        return\
        \ get_max_sum(nums)"
      programming_language: python3
      inputs:
      - nums: [1, 2, 3, 4, 5]
      - nums: [1, 2, 3, 4, 5, 6]
      - nums: [1, 2, 3, 4]
      - nums: [1, 2, 3, 4, 5, 6, 7]
      - nums: [1, 2, 3, 4, 5, 6, 7, 8]
      - nums: [1, 2, 3, 4, 5, 6, 7, 8, 9]
      - nums: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      - nums: [-1, 1, -1, 1, -1, 1]
      - nums: [-1, 1, -1, 1, -1, 1, -1, 1]
      - nums: [-1, 1, -1, 1, -1, 1, -1, 1, -1, 1]
      - nums: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      - nums: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      - nums: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      - nums: [-10, 10, -10, 10, -10, 10, -10, 10]
      - nums: [-10, 10, -10, 10, -10, 10, -10, 10, -10, 10]
      - nums: [-10, 10, -10, 10, -10, 10, -10, 10, -10, 10, -10, 10]
      - nums: [10, 20, 30, 40, 50]
      - nums: [10, 20, 30, 40, 50, 60]
      exec_results: [null, null, null, null, null, null, null, null, null, null, null,
        null, null, null, null, null, null, null]
    children: []
  - operation: [replace the traditional object-oriented design of the 'main' function
        in the 'code' key with a functional programming approach using immutable data
        structures and higher-order functions, 'revert the ''main'' function to its
        original object-oriented design, restoring mutable state and traditional method
        calls']
    middle_state:
      description: '**Maximum Subarray Sum of Odd Length**

        ===

        Given an array of integers `nums`, find the maximum sum of a subarray of odd
        length.

        A subarray is a contiguous part of the array.

        ===

        **Example 1**

        ===

        Input: `nums = [1,2,3,4,5]`

        Output: `9`

        Explanation: The maximum subarray sum of odd length is `[1,3,5]`, which has
        a sum of `9`.

        ===

        **Example 2**

        ===

        Input: `nums = [1,2,3,4,5,6]`

        Output: `14`

        Explanation: The maximum subarray sum of odd length is `[1,3,5,6]`, which
        has a sum of `14`.

        ===

        **Constraints**

        ===

        - `1 <= nums.length <= 2 * 10^5`

        - `-10^5 <= nums[i] <= 10^5`

        ===

        **Note**

        ===

        The input array will only contain integers.

        '
      code: "def main(nums):\n    def max_subarray_sum(start, end):\n        return\
        \ sum(nums[start:end+1])\n    \n    def max_odd_subarray_sum(start, end):\n\
        \        if (end - start) % 2 == 1:\n            return max_subarray_sum(start,\
        \ end)\n        else:\n            return 0\n    \n    n = len(nums)\n   \
        \ max_sum = float('-inf')\n    for i in range(n):\n        for j in range(i\
        \ + 1, n):\n            max_sum = max(max_sum, max_odd_subarray_sum(i, j))\n\
        \    return max_sum"
      programming_language: python3
      inputs:
      - nums: [1, 2, 3, 4, 5]
      - nums: [1, 2, 3, 4, 5, 6]
      - nums: [1, 2, 3, 4]
      - nums: [1, 2, 3, 4, 5, 6, 7]
      - nums: [1, 2, 3, 4, 5, 6, 7, 8]
      - nums: [1, 2, 3, 4, 5, 6, 7, 8, 9]
      - nums: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      - nums: [-1, 1, -1, 1, -1, 1]
      - nums: [-1, 1, -1, 1, -1, 1, -1, 1]
      - nums: [-1, 1, -1, 1, -1, 1, -1, 1, -1, 1]
      - nums: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      - nums: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      - nums: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      - nums: [-10, 10, -10, 10, -10, 10, -10, 10]
      - nums: [-10, 10, -10, 10, -10, 10, -10, 10, -10, 10]
      - nums: [-10, 10, -10, 10, -10, 10, -10, 10, -10, 10, -10, 10]
      - nums: [10, 20, 30, 40, 50]
      - nums: [10, 20, 30, 40, 50, 60]
      exec_results: [14, 21, 10, 27, 36, 44, 55, 0, 0, 0, 10, 10, 12, 0, 0, 0, 140,
        210]
    content:
      description: '**Maximum Subarray Sum of Odd Length**

        ===

        Given an array of integers `nums`, find the maximum sum of a subarray of odd
        length.

        A subarray is a contiguous part of the array.

        ===

        **Example 1**

        ===

        Input: `nums = [1,2,3,4,5]`

        Output: `9`

        Explanation: The maximum subarray sum of odd length is `[1,3,5]`, which has
        a sum of `9`.

        ===

        **Example 2**

        ===

        Input: `nums = [1,2,3,4,5,6]`

        Output: `14`

        Explanation: The maximum subarray sum of odd length is `[1,3,5,6]`, which
        has a sum of `14`.

        ===

        **Constraints**

        ===

        - `1 <= nums.length <= 2 * 10^5`

        - `-10^5 <= nums[i] <= 10^5`

        ===

        **Note**

        ===

        The input array will only contain integers.

        '
      code: "class MaxSubarray:\n    def __init__(self, nums):\n        self.nums\
        \ = nums\n        self.max_sum = float('-inf')\n\n    def max_subarray_sum(self,\
        \ start, end):\n        return sum(self.nums[start:end+1])\n\n    def max_odd_subarray_sum(self,\
        \ start, end):\n        if (end - start) % 2 == 1:\n            return self.max_subarray_sum(start,\
        \ end)\n        else:\n            return 0\n\n    def find_max_odd_subarray_sum(self):\n\
        \        n = len(self.nums)\n        for i in range(n):\n            for j\
        \ in range(i + 1, n):\n                self.max_sum = max(self.max_sum, self.max_odd_subarray_sum(i,\
        \ j))\n        return self.max_sum\n\ndef main(nums):\n    max_subarray =\
        \ MaxSubarray(nums)\n    return max_subarray.find_max_odd_subarray_sum()"
      programming_language: python3
      inputs:
      - nums: [1, 2, 3, 4, 5]
      - nums: [1, 2, 3, 4, 5, 6]
      - nums: [1, 2, 3, 4]
      - nums: [1, 2, 3, 4, 5, 6, 7]
      - nums: [1, 2, 3, 4, 5, 6, 7, 8]
      - nums: [1, 2, 3, 4, 5, 6, 7, 8, 9]
      - nums: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      - nums: [-1, 1, -1, 1, -1, 1]
      - nums: [-1, 1, -1, 1, -1, 1, -1, 1]
      - nums: [-1, 1, -1, 1, -1, 1, -1, 1, -1, 1]
      - nums: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      - nums: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      - nums: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      - nums: [-10, 10, -10, 10, -10, 10, -10, 10]
      - nums: [-10, 10, -10, 10, -10, 10, -10, 10, -10, 10]
      - nums: [-10, 10, -10, 10, -10, 10, -10, 10, -10, 10, -10, 10]
      - nums: [10, 20, 30, 40, 50]
      - nums: [10, 20, 30, 40, 50, 60]
      exec_results: [14, 21, 10, 27, 36, 44, 55, 0, 0, 0, 10, 10, 12, 0, 0, 0, 140,
        210]
    children: []
  - operation: ['replace the iterative approach used in the ''main'' function in the
        ''code'' key with a recursive one, utilizing memoization to avoid redundant
        calculations', 'revert the ''main'' function to its original iterative approach,
        removing memoization and traditional loop constructs']
    middle_state:
      description: '**Maximum Subarray Sum of Odd Length**

        ===

        Given an array of integers `nums`, find the maximum sum of a subarray of odd
        length.

        A subarray is a contiguous part of the array.

        ===

        **Example 1**

        ===

        Input: `nums = [1,2,3,4,5]`

        Output: `9`

        Explanation: The maximum subarray sum of odd length is `[1,3,5]`, which has
        a sum of `9`.

        ===

        **Example 2**

        ===

        Input: `nums = [1,2,3,4,5,6]`

        Output: `14`

        Explanation: The maximum subarray sum of odd length is `[1,3,5,6]`, which
        has a sum of `14`.

        ===

        **Constraints**

        ===

        - `1 <= nums.length <= 2 * 10^5`

        - `-10^5 <= nums[i] <= 10^5`

        ===

        **Note**

        ===

        The input array will only contain integers.

        '
      code: "def max_rob(nums):\n    def helper(i, memo):\n        if i >= len(nums):\n\
        \            return 0\n        if i in memo:\n            return memo[i]\n\
        \        if i + 1 == len(nums):\n            return nums[i]\n        if (i\
        \ + 1) % 2 == 1:\n            memo[i] = max(nums[i] + helper(i + 2, memo),\
        \ helper(i + 1, memo))\n            return memo[i]\n        memo[i] = max(nums[i]\
        \ + helper(i + 2, memo), helper(i + 1, memo))\n        return memo[i]\n  \
        \  memo = {}\n    return helper(0, memo)"
      programming_language: python3
      inputs:
      - nums: [1, 2, 3, 4, 5]
      - nums: [1, 2, 3, 4, 5, 6]
      - nums: [1, 2, 3, 4]
      - nums: [1, 2, 3, 4, 5, 6, 7]
      - nums: [1, 2, 3, 4, 5, 6, 7, 8]
      - nums: [1, 2, 3, 4, 5, 6, 7, 8, 9]
      - nums: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      - nums: [-1, 1, -1, 1, -1, 1]
      - nums: [-1, 1, -1, 1, -1, 1, -1, 1]
      - nums: [-1, 1, -1, 1, -1, 1, -1, 1, -1, 1]
      - nums: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      - nums: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      - nums: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      - nums: [-10, 10, -10, 10, -10, 10, -10, 10]
      - nums: [-10, 10, -10, 10, -10, 10, -10, 10, -10, 10]
      - nums: [-10, 10, -10, 10, -10, 10, -10, 10, -10, 10, -10, 10]
      - nums: [10, 20, 30, 40, 50]
      - nums: [10, 20, 30, 40, 50, 60]
      exec_results: [null, null, null, null, null, null, null, null, null, null, null,
        null, null, null, null, null, null, null]
    content:
      description: '**Maximum Subarray Sum of Odd Length**

        ===

        Given an array of integers `nums`, find the maximum sum of a subarray of odd
        length.

        A subarray is a contiguous part of the array.

        ===

        **Example 1**

        ===

        Input: `nums = [1,2,3,4,5]`

        Output: `9`

        Explanation: The maximum subarray sum of odd length is `[1,3,5]`, which has
        a sum of `9`.

        ===

        **Example 2**

        ===

        Input: `nums = [1,2,3,4,5,6]`

        Output: `14`

        Explanation: The maximum subarray sum of odd length is `[1,3,5,6]`, which
        has a sum of `14`.

        ===

        **Constraints**

        ===

        - `1 <= nums.length <= 2 * 10^5`

        - `-10^5 <= nums[i] <= 10^5`

        ===

        **Note**

        ===

        The input array will only contain integers.

        '
      code: "def max_rob(nums):\n    if not nums:\n        return 0\n    if len(nums)\
        \ == 1:\n        return nums[0]\n    if len(nums) == 2:\n        return max(nums[0],\
        \ nums[1])\n    odd = [0 for _ in range(len(nums))]\n    even = [0 for _ in\
        \ range(len(nums))]\n    odd[1] = nums[0]\n    even[1] = nums[1]\n    even[2]\
        \ = max(nums[0], nums[1])\n    for i in range(3, len(nums)):\n        if i\
        \ % 2 == 1:\n            odd[i] = max(odd[i-2] + nums[i], even[i-1])\n   \
        \     else:\n            even[i] = max(even[i-2] + nums[i], odd[i-1])\n  \
        \  return max(odd[-1], even[-1])"
      programming_language: python3
      inputs:
      - nums: [1, 2, 3, 4, 5]
      - nums: [1, 2, 3, 4, 5, 6]
      - nums: [1, 2, 3, 4]
      - nums: [1, 2, 3, 4, 5, 6, 7]
      - nums: [1, 2, 3, 4, 5, 6, 7, 8]
      - nums: [1, 2, 3, 4, 5, 6, 7, 8, 9]
      - nums: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      - nums: [-1, 1, -1, 1, -1, 1]
      - nums: [-1, 1, -1, 1, -1, 1, -1, 1]
      - nums: [-1, 1, -1, 1, -1, 1, -1, 1, -1, 1]
      - nums: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      - nums: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      - nums: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      - nums: [-10, 10, -10, 10, -10, 10, -10, 10]
      - nums: [-10, 10, -10, 10, -10, 10, -10, 10, -10, 10]
      - nums: [-10, 10, -10, 10, -10, 10, -10, 10, -10, 10, -10, 10]
      - nums: [10, 20, 30, 40, 50]
      - nums: [10, 20, 30, 40, 50, 60]
      exec_results: [null, null, null, null, null, null, null, null, null, null, null,
        null, null, null, null, null, null, null]
    children: []
