operations:
- [replace the 'main' function in the 'code' key with a class-based implementation
    that utilizes metaclasses and decorators to encapsulate and extend functionality,
  'revert the ''main'' function to its original form, removing all class-based implementation
    and metaclasses']
- [replace the root code's JSON structure with a nested dictionary implementation
    using a custom context manager to handle memory management, 'revert the root code
    to its original JSON structure, removing all nested dictionary implementation
    and custom context manager']
- ['utilize a custom operator overloading system to redefine the behavior of built-in
    operators within the ''main'' function in the ''code'' key, allowing for more
    complex and domain-specific calculations', 'revert the ''main'' function to use
    standard operator overloading, removing all custom operator redefinitions']
metrics:
  embedding similarity L-1 AVG: 0.8864436806502427
  embedding similarity L-1: [0.9458975174916622, 0.7134335244590657, 1.0000000000000002]
  BLEU L-1 AVG: 0.398028744235424
  BLEU L-1: [0.194086232706272, 0, 1.0]
  ROUGE-rouge1 L-1 AVG: 0.5614035087719298
  ROUGE-rouge1 L-1: [0.6842105263157895, 0.0, 1.0]
  ROUGE-rouge2 L-1 AVG: 0.5
  ROUGE-rouge2 L-1: [0.5, 0.0, 1.0]
  ROUGE-rougeL L-1 AVG: 0.5614035087719298
  ROUGE-rougeL L-1: [0.6842105263157895, 0, 1.0]
  embedding similarity L-2 AVG: 0.0
  embedding similarity L-2: []
  BLEU L-2 AVG: 0.0
  BLEU L-2: []
  ROUGE-rouge1 L-2 AVG: 0.0
  ROUGE-rouge1 L-2: []
  ROUGE-rouge2 L-2 AVG: 0.0
  ROUGE-rouge2 L-2: []
  ROUGE-rougeL L-2 AVG: 0.0
  ROUGE-rougeL L-2: []
  embedding similarity L-3 AVG: 0.0
  embedding similarity L-3: []
  BLEU L-3 AVG: 0.0
  BLEU L-3: []
  ROUGE-rouge1 L-3 AVG: 0.0
  ROUGE-rouge1 L-3: []
  ROUGE-rouge2 L-3 AVG: 0.0
  ROUGE-rouge2 L-3: []
  ROUGE-rougeL L-3 AVG: 0.0
  ROUGE-rougeL L-3: []
evaluatee_model: {model: fireworks_ai/accounts/fireworks/models/llama-v3p1-8b-instruct,
  temperature: 0.6, api_base: 'https://api.fireworks.ai/inference/v1'}
root_content:
  description: '**Maximum Subarray Product of Three Numbers**


    Given an integer array `nums`, return the maximum product of three numbers from
    the array.


    A single number can be used more than once to reach the maximum product and you
    cannot choose a number more than once.


    **Example 1:**


    Input: `nums = [1,2,3]`

    Output: `6`


    **Example 2:**


    Input: `[1,2,-2,3]`

    Output: `6`


    **Example 3:**


    Input: `[-1,-2,-3]`

    Output: `6`


    **Constraints:**


    *   `-1000 <= nums[i] <= 1000`

    *   `1 <= nums.length <= 10^5`

    '
  code: "def main(nums):\n  if not nums:\n    return 0\n  if len(nums) == 1:\n   \
    \ return nums[0]\n  if len(nums) == 2:\n    return max(nums[0] * nums[1], nums[0],\
    \ nums[1])\n  if len(nums) == 3:\n    return max(nums[0] * nums[1] * nums[2],\
    \ nums[0] * nums[1], nums[1] * nums[2], nums[0] * nums[2])\n  res = float('-inf')\n\
    \  max1 = max2 = max3 = float('-inf')\n  min1 = min2 = float('inf')\n  for n in\
    \ nums:\n    if n > max1:\n      max3 = max2\n      max2 = max1\n      max1 =\
    \ n\n    elif n > max2:\n      max3 = max2\n      max2 = n\n    elif n > max3:\n\
    \      max3 = n\n    if n < min1:\n      min2 = min1\n      min1 = n\n    elif\
    \ n < min2:\n      min2 = n\n  return max(max1 * max2 * max3, max1 * min1 * min2)\n"
  programming_language: python3
  inputs:
  - nums: [1, 2, 3]
  - nums: [1, 2, -2, 3]
  - nums: [-1, -2, -3]
  - nums: [-1, -2, 3]
  - nums: [-2, -3, 4]
  - nums: [1, -2, 3]
  - nums: [1, -2, 4]
  - nums: [1, 2, -3]
  - nums: [1, 2, -4]
  - nums: [1, -3, -4]
  - nums: [-1, -3, 4]
  - nums: [-1, -2, 4]
  - nums: [-1, -3, 4]
  - nums: [1, -3, 4]
  - nums: [1, -2, -3]
  - nums: [-1, 2, -3]
  - nums: [-1, -2, -3]
  - nums: [1, 2, -3]
  - nums: [1, 1, 1]
  exec_results: [6, 6, 6, 6, 24, 3, 4, 2, 2, 12, 12, 8, 12, 4, 6, 6, 6, 2, 1]
tree:
  operation: null
  middle_state: null
  content:
    description: '**Maximum Subarray Product of Three Numbers**


      Given an integer array `nums`, return the maximum product of three numbers from
      the array.


      A single number can be used more than once to reach the maximum product and
      you cannot choose a number more than once.


      **Example 1:**


      Input: `nums = [1,2,3]`

      Output: `6`


      **Example 2:**


      Input: `[1,2,-2,3]`

      Output: `6`


      **Example 3:**


      Input: `[-1,-2,-3]`

      Output: `6`


      **Constraints:**


      *   `-1000 <= nums[i] <= 1000`

      *   `1 <= nums.length <= 10^5`

      '
    code: "def main(nums):\n  if not nums:\n    return 0\n  if len(nums) == 1:\n \
      \   return nums[0]\n  if len(nums) == 2:\n    return max(nums[0] * nums[1],\
      \ nums[0], nums[1])\n  if len(nums) == 3:\n    return max(nums[0] * nums[1]\
      \ * nums[2], nums[0] * nums[1], nums[1] * nums[2], nums[0] * nums[2])\n  res\
      \ = float('-inf')\n  max1 = max2 = max3 = float('-inf')\n  min1 = min2 = float('inf')\n\
      \  for n in nums:\n    if n > max1:\n      max3 = max2\n      max2 = max1\n\
      \      max1 = n\n    elif n > max2:\n      max3 = max2\n      max2 = n\n   \
      \ elif n > max3:\n      max3 = n\n    if n < min1:\n      min2 = min1\n    \
      \  min1 = n\n    elif n < min2:\n      min2 = n\n  return max(max1 * max2 *\
      \ max3, max1 * min1 * min2)\n"
    programming_language: python3
    inputs:
    - nums: [1, 2, 3]
    - nums: [1, 2, -2, 3]
    - nums: [-1, -2, -3]
    - nums: [-1, -2, 3]
    - nums: [-2, -3, 4]
    - nums: [1, -2, 3]
    - nums: [1, -2, 4]
    - nums: [1, 2, -3]
    - nums: [1, 2, -4]
    - nums: [1, -3, -4]
    - nums: [-1, -3, 4]
    - nums: [-1, -2, 4]
    - nums: [-1, -3, 4]
    - nums: [1, -3, 4]
    - nums: [1, -2, -3]
    - nums: [-1, 2, -3]
    - nums: [-1, -2, -3]
    - nums: [1, 2, -3]
    - nums: [1, 1, 1]
    exec_results: [6, 6, 6, 6, 24, 3, 4, 2, 2, 12, 12, 8, 12, 4, 6, 6, 6, 2, 1]
  children:
  - operation: [replace the 'main' function in the 'code' key with a class-based implementation
        that utilizes metaclasses and decorators to encapsulate and extend functionality,
      'revert the ''main'' function to its original form, removing all class-based
        implementation and metaclasses']
    middle_state:
      description: '**Maximum Subarray Product of Three Numbers**


        Given an integer array `nums`, return the maximum product of three numbers
        from the array.


        A single number can be used more than once to reach the maximum product and
        you cannot choose a number more than once.


        **Example 1:**


        Input: `nums = [1,2,3]`

        Output: `6`


        **Example 2:**


        Input: `[1,2,-2,3]`

        Output: `6`


        **Example 3:**


        Input: `[-1,-2,-3]`

        Output: `6`


        **Constraints:**


        *   `-1000 <= nums[i] <= 1000`

        *   `1 <= nums.length <= 10^5`

        '
      code: "class MaxFinder:\n  def __init__(self):\n    self.max1 = self.max2 =\
        \ self.max3 = float('-inf')\n    self.min1 = self.min2 = float('inf')\n\n\
        \  def __call__(self, n):\n    if n > self.max1:\n      self.max3 = self.max2\n\
        \      self.max2 = self.max1\n      self.max1 = n\n    elif n > self.max2:\n\
        \      self.max3 = self.max2\n      self.max2 = n\n    elif n > self.max3:\n\
        \      self.max3 = n\n    if n < self.min1:\n      self.min2 = self.min1\n\
        \      self.min1 = n\n    elif n < self.min2:\n      self.min2 = n\n\nclass\
        \ MaximumProductFinder:\n  def __init__(self):\n    self.max_finder = MaxFinder()\n\
        \    self.min_finder = MaxFinder()\n\n  def __call__(self, nums):\n    return\
        \ max(self.max_finder.max1 * self.max_finder.max2 * self.max_finder.max3,\n\
        \              self.max_finder.max1 * self.min_finder.min1 * self.min_finder.min2)\n\
        \ndef main(nums):\n  finder = MaximumProductFinder()\n  for num in nums:\n\
        \    finder(num)\n  return finder(nums)"
      programming_language: python3
      inputs:
      - nums: [1, 2, 3]
      - nums: [1, 2, -2, 3]
      - nums: [-1, -2, -3]
      - nums: [-1, -2, 3]
      - nums: [-2, -3, 4]
      - nums: [1, -2, 3]
      - nums: [1, -2, 4]
      - nums: [1, 2, -3]
      - nums: [1, 2, -4]
      - nums: [1, -3, -4]
      - nums: [-1, -3, 4]
      - nums: [-1, -2, 4]
      - nums: [-1, -3, 4]
      - nums: [1, -3, 4]
      - nums: [1, -2, -3]
      - nums: [-1, 2, -3]
      - nums: [-1, -2, -3]
      - nums: [1, 2, -3]
      - nums: [1, 1, 1]
      exec_results: [-.inf, -.inf, -.inf, -.inf, -.inf, -.inf, -.inf, -.inf, -.inf,
        -.inf, -.inf, -.inf, -.inf, -.inf, -.inf, -.inf, -.inf, -.inf, -.inf]
    content:
      description: '**Maximum Subarray Product of Three Numbers**


        Given an integer array `nums`, return the maximum product of three numbers
        from the array.


        A single number can be used more than once to reach the maximum product and
        you cannot choose a number more than once.


        **Example 1:**


        Input: `nums = [1,2,3]`

        Output: `6`


        **Example 2:**


        Input: `[1,2,-2,3]`

        Output: `6`


        **Example 3:**


        Input: `[-1,-2,-3]`

        Output: `6`


        **Constraints:**


        *   `-1000 <= nums[i] <= 1000`

        *   `1 <= nums.length <= 10^5`

        '
      code: "def main(nums):\n  max1 = max2 = max3 = float('-inf')\n  min1 = min2\
        \ = float('inf')\n\n  for n in nums:\n    if n > max1:\n      max3 = max2\n\
        \      max2 = max1\n      max1 = n\n    elif n > max2:\n      max3 = max2\n\
        \      max2 = n\n    elif n > max3:\n      max3 = n\n    if n < min1:\n  \
        \    min2 = min1\n      min1 = n\n    elif n < min2:\n      min2 = n\n\n \
        \ return max(max1 * max2 * max3, max1 * min1 * min2)"
      programming_language: python3
      inputs:
      - nums: [1, 2, 3]
      - nums: [1, 2, -2, 3]
      - nums: [-1, -2, -3]
      - nums: [-1, -2, 3]
      - nums: [-2, -3, 4]
      - nums: [1, -2, 3]
      - nums: [1, -2, 4]
      - nums: [1, 2, -3]
      - nums: [1, 2, -4]
      - nums: [1, -3, -4]
      - nums: [-1, -3, 4]
      - nums: [-1, -2, 4]
      - nums: [-1, -3, 4]
      - nums: [1, -3, 4]
      - nums: [1, -2, -3]
      - nums: [-1, 2, -3]
      - nums: [-1, -2, -3]
      - nums: [1, 2, -3]
      - nums: [1, 1, 1]
      exec_results: [6, 6, -6, 6, 24, -6, -8, -6, -8, 12, 12, 8, 12, -12, 6, 6, -6,
        -6, 1]
    children: []
  - operation: [replace the root code's JSON structure with a nested dictionary implementation
        using a custom context manager to handle memory management, 'revert the root
        code to its original JSON structure, removing all nested dictionary implementation
        and custom context manager']
    middle_state:
      description: '**Maximum Subarray Product of Three Numbers**


        Given an integer array `nums`, return the maximum product of three numbers
        from the array.


        A single number can be used more than once to reach the maximum product and
        you cannot choose a number more than once.


        **Example 1:**


        Input: `nums = [1,2,3]`

        Output: `6`


        **Example 2:**


        Input: `[1,2,-2,3]`

        Output: `6`


        **Example 3:**


        Input: `[-1,-2,-3]`

        Output: `6`


        **Constraints:**


        *   `-1000 <= nums[i] <= 1000`

        *   `1 <= nums.length <= 10^5`

        '
      code: "class MaxHeap:\n    def __init__(self):\n        self.heap = []\n\n \
        \   def push(self, num):\n        self.heap.append(num)\n        self._heapify_up(len(self.heap)\
        \ - 1)\n\n    def pop(self):\n        if len(self.heap) == 0:\n          \
        \  return None\n        if len(self.heap) == 1:\n            return self.heap.pop(0)\n\
        \        max_val = self.heap[0]\n        self.heap[0] = self.heap.pop()\n\
        \        self._heapify_down(0)\n        return max_val\n\n    def _heapify_up(self,\
        \ index):\n        parent_index = (index - 1) // 2\n        if index <= 0:\n\
        \            return\n        elif self.heap[parent_index] < self.heap[index]:\n\
        \            self.heap[parent_index], self.heap[index] = self.heap[index],\
        \ self.heap[parent_index]\n            self._heapify_up(parent_index)\n\n\
        \    def _heapify_down(self, index):\n        left_child_index = 2 * index\
        \ + 1\n        right_child_index = 2 * index + 2\n        largest = index\n\
        \        if len(self.heap) > left_child_index and self.heap[left_child_index]\
        \ > self.heap[largest]:\n            largest = left_child_index\n        if\
        \ len(self.heap) > right_child_index and self.heap[right_child_index] > self.heap[largest]:\n\
        \            largest = right_child_index\n        if largest != index:\n \
        \           self.heap[largest], self.heap[index] = self.heap[index], self.heap[largest]\n\
        \            self._heapify_down(largest)\n\ndef main(nums):\n    if not nums:\n\
        \        return 0\n    if len(nums) == 1:\n        return nums[0]\n    if\
        \ len(nums) == 2:\n        return max(nums[0] * nums[1], nums[0], nums[1])\n\
        \    if len(nums) == 3:\n        return max(nums[0] * nums[1] * nums[2], nums[0]\
        \ * nums[1], nums[1] * nums[2], nums[0] * nums[2])\n    max_heap = MaxHeap()\n\
        \    min_heap = MaxHeap()\n    for n in nums:\n        max_heap.push(n)\n\
        \        min_heap.push(-n)\n    return max(max_heap.heap[0] * max_heap.heap[1]\
        \ * max_heap.heap[2], max_heap.heap[0] * min_heap.heap[0] * min_heap.heap[1])"
      programming_language: python3
      inputs:
      - nums: [1, 2, 3]
      - nums: [1, 2, -2, 3]
      - nums: [-1, -2, -3]
      - nums: [-1, -2, 3]
      - nums: [-2, -3, 4]
      - nums: [1, -2, 3]
      - nums: [1, -2, 4]
      - nums: [1, 2, -3]
      - nums: [1, 2, -4]
      - nums: [1, -3, -4]
      - nums: [-1, -3, 4]
      - nums: [-1, -2, 4]
      - nums: [-1, -3, 4]
      - nums: [1, -3, 4]
      - nums: [1, -2, -3]
      - nums: [-1, 2, -3]
      - nums: [-1, -2, -3]
      - nums: [1, 2, -3]
      - nums: [1, 1, 1]
      exec_results: [6, -12, 6, 6, 24, 3, 4, 2, 2, 12, 12, 8, 12, 4, 6, 6, 6, 2, 1]
    content:
      description: '**Maximum Subarray Product of Three Numbers**


        Given an integer array `nums`, return the maximum product of three numbers
        from the array.


        A single number can be used more than once to reach the maximum product and
        you cannot choose a number more than once.


        **Example 1:**


        Input: `nums = [1,2,3]`

        Output: `6`


        **Example 2:**


        Input: `[1,2,-2,3]`

        Output: `6`


        **Example 3:**


        Input: `[-1,-2,-3]`

        Output: `6`


        **Constraints:**


        *   `-1000 <= nums[i] <= 1000`

        *   `1 <= nums.length <= 10^5`

        '
      code: "class MaxHeap {\n  constructor() {\n    this.heap = [];\n  }\n\n  push(num)\
        \ {\n    this.heap.push(num);\n    this.heapifyUp(this.heap.length - 1);\n\
        \  }\n\n  pop() {\n    if (this.heap.length === 0) {\n      return null;\n\
        \    }\n    if (this.heap.length === 1) {\n      return this.heap.pop();\n\
        \    }\n    let maxVal = this.heap[0];\n    this.heap[0] = this.heap.pop();\n\
        \    this.heapifyDown(0);\n    return maxVal;\n  }\n\n  heapifyUp(index) {\n\
        \    let parentIndex = Math.floor((index - 1) / 2);\n    if (index <= 0) {\n\
        \      return;\n    } else if (this.heap[parentIndex] < this.heap[index])\
        \ {\n      let temp = this.heap[parentIndex];\n      this.heap[parentIndex]\
        \ = this.heap[index];\n      this.heap[index] = temp;\n      this.heapifyUp(parentIndex);\n\
        \    }\n  }\n\n  heapifyDown(index) {\n    let leftChildIndex = 2 * index\
        \ + 1;\n    let rightChildIndex = 2 * index + 2;\n    let largest = index;\n\
        \    if (this.heap.length > leftChildIndex && this.heap[leftChildIndex] >\
        \ this.heap[largest]) {\n      largest = leftChildIndex;\n    }\n    if (this.heap.length\
        \ > rightChildIndex && this.heap[rightChildIndex] > this.heap[largest]) {\n\
        \      largest = rightChildIndex;\n    }\n    if (largest !== index) {\n \
        \     let temp = this.heap[largest];\n      this.heap[largest] = this.heap[index];\n\
        \      this.heap[index] = temp;\n      this.heapifyDown(largest);\n    }\n\
        \  }\n}\n\nfunction main(nums) {\n  if (nums.length === 0) {\n    return 0;\n\
        \  }\n  if (nums.length === 1) {\n    return nums[0];\n  }\n  if (nums.length\
        \ === 2) {\n    return Math.max(nums[0] * nums[1], nums[0], nums[1]);\n  }\n\
        \  if (nums.length === 3) {\n    return Math.max(nums[0] * nums[1] * nums[2],\
        \ nums[0] * nums[1], nums[1] * nums[2], nums[0] * nums[2]);\n  }\n  let maxHeap\
        \ = new MaxHeap();\n  let minHeap = new MaxHeap();\n  for (let n of nums)\
        \ {\n    maxHeap.push(n);\n    minHeap.push(-n);\n  }\n  return Math.max(maxHeap.heap[0]\
        \ * maxHeap.heap[1] * maxHeap.heap[2], maxHeap.heap[0] * minHeap.heap[0] *\
        \ minHeap.heap[1]);\n}"
      programming_language: javascript
      inputs:
      - nums: [1, 2, 3]
      - nums: [1, 2, -2, 3]
      - nums: [-1, -2, -3]
      - nums: [-1, -2, 3]
      - nums: [-2, -3, 4]
      - nums: [1, -2, 3]
      - nums: [1, -2, 4]
      - nums: [1, 2, -3]
      - nums: [1, 2, -4]
      - nums: [1, -3, -4]
      - nums: [-1, -3, 4]
      - nums: [-1, -2, 4]
      - nums: [-1, -3, 4]
      - nums: [1, -3, 4]
      - nums: [1, -2, -3]
      - nums: [-1, 2, -3]
      - nums: [-1, -2, -3]
      - nums: [1, 2, -3]
      - nums: [1, 1, 1]
      exec_results: []
    children: []
  - operation: ['utilize a custom operator overloading system to redefine the behavior
        of built-in operators within the ''main'' function in the ''code'' key, allowing
        for more complex and domain-specific calculations', 'revert the ''main'' function
        to use standard operator overloading, removing all custom operator redefinitions']
    middle_state:
      description: '**Maximum Subarray Product of Three Numbers**


        Given an integer array `nums`, return the maximum product of three numbers
        from the array.


        A single number can be used more than once to reach the maximum product and
        you cannot choose a number more than once.


        **Example 1:**


        Input: `nums = [1,2,3]`

        Output: `6`


        **Example 2:**


        Input: `[1,2,-2,3]`

        Output: `6`


        **Example 3:**


        Input: `[-1,-2,-3]`

        Output: `6`


        **Constraints:**


        *   `-1000 <= nums[i] <= 1000`

        *   `1 <= nums.length <= 10^5`

        '
      code: "class Number:\n    def __init__(self, value):\n        self.value = value\n\
        \n    def __mul__(self, other):\n        return Number(self.value * other.value)\n\
        \n    def __add__(self, other):\n        return Number(self.value + other.value)\n\
        \n    def __sub__(self, other):\n        return Number(self.value - other.value)\n\
        \n    def __truediv__(self, other):\n        return Number(self.value / other.value)\n\
        \n    def __eq__(self, other):\n        return self.value == other.value\n\
        \n    def __lt__(self, other):\n        return self.value < other.value\n\n\
        \    def __gt__(self, other):\n        return self.value > other.value\n\n\
        \    def __le__(self, other):\n        return self.value <= other.value\n\n\
        \    def __ge__(self, other):\n        return self.value >= other.value\n\n\
        def main(nums):\n    if not nums:\n        return Number(0)\n    if len(nums)\
        \ == 1:\n        return nums[0]\n    if len(nums) == 2:\n        return max(nums[0],\
        \ nums[0] * nums[1], nums[1])\n    if len(nums) == 3:\n        return max(nums[0],\
        \ nums[0] * nums[1], nums[1], nums[0] * nums[2], nums[1] * nums[2], nums[0]\
        \ * nums[1] * nums[2])\n    res = Number('-inf')\n    max1 = max2 = max3 =\
        \ Number('-inf')\n    min1 = min2 = Number('inf')\n    for n in nums:\n  \
        \      if n > max1:\n            max3 = max2\n            max2 = max1\n  \
        \          max1 = n\n        elif n > max2:\n            max3 = max2\n   \
        \         max2 = n\n        elif n > max3:\n            max3 = n\n       \
        \ if n < min1:\n            min2 = min1\n            min1 = n\n        elif\
        \ n < min2:\n            min2 = n\n    return max(max1 * max2 * max3, max1\
        \ * min1 * min2)"
      programming_language: python3
      inputs:
      - nums: [1, 2, 3]
      - nums: [1, 2, -2, 3]
      - nums: [-1, -2, -3]
      - nums: [-1, -2, 3]
      - nums: [-2, -3, 4]
      - nums: [1, -2, 3]
      - nums: [1, -2, 4]
      - nums: [1, 2, -3]
      - nums: [1, 2, -4]
      - nums: [1, -3, -4]
      - nums: [-1, -3, 4]
      - nums: [-1, -2, 4]
      - nums: [-1, -3, 4]
      - nums: [1, -3, 4]
      - nums: [1, -2, -3]
      - nums: [-1, 2, -3]
      - nums: [-1, -2, -3]
      - nums: [1, 2, -3]
      - nums: [1, 1, 1]
      exec_results: [6, null, 6, 6, 24, 3, 4, 2, 2, 12, 12, 8, 12, 4, 6, 6, 6, 2,
        1]
    content:
      description: '**Maximum Subarray Product of Three Numbers**


        Given an integer array `nums`, return the maximum product of three numbers
        from the array.


        A single number can be used more than once to reach the maximum product and
        you cannot choose a number more than once.


        **Example 1:**


        Input: `nums = [1,2,3]`

        Output: `6`


        **Example 2:**


        Input: `[1,2,-2,3]`

        Output: `6`


        **Example 3:**


        Input: `[-1,-2,-3]`

        Output: `6`


        **Constraints:**


        *   `-1000 <= nums[i] <= 1000`

        *   `1 <= nums.length <= 10^5`

        '
      code: "def main(nums):\n    if not nums:\n        return 0\n    if len(nums)\
        \ == 1:\n        return nums[0]\n    if len(nums) == 2:\n        return max(nums[0],\
        \ nums[0] * nums[1], nums[1])\n    if len(nums) == 3:\n        return max(nums[0],\
        \ nums[0] * nums[1], nums[1], nums[0] * nums[2], nums[1] * nums[2], nums[0]\
        \ * nums[1] * nums[2])\n    res = float('-inf')\n    max1 = max2 = max3 =\
        \ float('-inf')\n    min1 = min2 = float('inf')\n    for n in nums:\n    \
        \    if n > max1:\n            max3 = max2\n            max2 = max1\n    \
        \        max1 = n\n        elif n > max2:\n            max3 = max2\n     \
        \       max2 = n\n        elif n > max3:\n            max3 = n\n        if\
        \ n < min1:\n            min2 = min1\n            min1 = n\n        elif n\
        \ < min2:\n            min2 = n\n    return max(max1 * max2 * max3, max1 *\
        \ min1 * min2)"
      programming_language: python3
      inputs:
      - nums: [1, 2, 3]
      - nums: [1, 2, -2, 3]
      - nums: [-1, -2, -3]
      - nums: [-1, -2, 3]
      - nums: [-2, -3, 4]
      - nums: [1, -2, 3]
      - nums: [1, -2, 4]
      - nums: [1, 2, -3]
      - nums: [1, 2, -4]
      - nums: [1, -3, -4]
      - nums: [-1, -3, 4]
      - nums: [-1, -2, 4]
      - nums: [-1, -3, 4]
      - nums: [1, -3, 4]
      - nums: [1, -2, -3]
      - nums: [-1, 2, -3]
      - nums: [-1, -2, -3]
      - nums: [1, 2, -3]
      - nums: [1, 1, 1]
      exec_results: [6, 6, 6, 6, 24, 3, 4, 2, 2, 12, 12, 8, 12, 4, 6, 6, 6, 2, 1]
    children: []
