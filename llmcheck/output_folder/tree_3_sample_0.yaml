operations:
- ['1. Convert the recursive function calls within the ''main'' function in the ''code''
    key into an iterative approach using a stack data structure, carefully managing
    function call and return stack.', 'Convert the iterative approach back into the
    original recursive function calls, preserving the original logic and function
    call order.']
- ['2. Utilize a non-standard but equivalent mathematical approach to calculate the
    ''result'' variable in the ''main'' function in the ''code'' key, replacing arithmetic
    operations with bitwise operations and cleverly using bitwise properties.', 'Revert
    the ''result'' calculation back to the standard arithmetic operations, ensuring
    the result remains identical.']
- ['3. Replace the ''if-else'' statements within the ''main'' function in the ''code''
    key with a complex decision tree data structure, utilizing a combination of binary
    search and hash tables to evaluate conditions.', 'Convert the decision tree back
    into the original ''if-else'' statements, preserving the original logic and condition
    evaluations.']
metrics:
  embedding similarity L-1 AVG: 0.8818971884686242
  embedding similarity L-1: [0.9168108842847926, 0.9999999999999998, 0.72888068112108]
  BLEU L-1 AVG: 0.3504049632037161
  BLEU L-1: [0.05121488961114836, 1.0, 0]
  ROUGE-rouge1 L-1 AVG: 0.39999999999999997
  ROUGE-rouge1 L-1: [0.20000000000000004, 1.0, 0.0]
  ROUGE-rouge2 L-1 AVG: 0.3684210526315789
  ROUGE-rouge2 L-1: [0.10526315789473684, 1.0, 0.0]
  ROUGE-rougeL L-1 AVG: 0.39999999999999997
  ROUGE-rougeL L-1: [0.20000000000000004, 1.0, 0]
  embedding similarity L-2 AVG: 0.0
  embedding similarity L-2: []
  BLEU L-2 AVG: 0.0
  BLEU L-2: []
  ROUGE-rouge1 L-2 AVG: 0.0
  ROUGE-rouge1 L-2: []
  ROUGE-rouge2 L-2 AVG: 0.0
  ROUGE-rouge2 L-2: []
  ROUGE-rougeL L-2 AVG: 0.0
  ROUGE-rougeL L-2: []
  embedding similarity L-3 AVG: 0.0
  embedding similarity L-3: []
  BLEU L-3 AVG: 0.0
  BLEU L-3: []
  ROUGE-rouge1 L-3 AVG: 0.0
  ROUGE-rouge1 L-3: []
  ROUGE-rouge2 L-3 AVG: 0.0
  ROUGE-rouge2 L-3: []
  ROUGE-rougeL L-3 AVG: 0.0
  ROUGE-rougeL L-3: []
evaluatee_model: {model: fireworks_ai/accounts/fireworks/models/llama-v3p1-8b-instruct,
  temperature: 0.6, api_base: 'https://api.fireworks.ai/inference/v1'}
root_content:
  description: "**Maximum Subarray Sum with K Consecutive Elements**\n\nGiven an array\
    \ of integers `nums` and an integer `k`, find the maximum sum of a subarray of\
    \ length `k` that appears in `nums`. If no such subarray exists, return 0.\n\n\
    A subarray is a contiguous part of an array.\n\n**Example 1:**\n\n  Input: nums\
    \ = [1,2,3,4,5], k = 3\n  Output: 12\n  Explanation: The maximum sum is 1 + 2\
    \ + 3 = 6, but the subarray [1,2,3] appears more than once, so the answer is the\
    \ maximum sum which is 1 + 2 + 3 + 4 = 10, but the maximum sum is 1 + 2 + 3 =\
    \ 6 + 5 = 11, but the maximum sum is 1 + 2 + 3 + 4 + 5 = 15, so the answer is\
    \ 15\n\n**Example 2:**\n\n  Input: nums = [1,2], k = 3\n  Output: 0\n  Explanation:\
    \ The length of the array is 2, so the maximum sum of a subarray of length 3 that\
    \ appears in `nums` is 0.\n\n**Constraints:**\n\n  * `1 <= nums.length <= 10^5`\n\
    \  * `1 <= k <= nums.length`\n  * `-10^4 <= nums[i] <= 10^4`\n"
  code: "def main(nums, k):\n  n = len(nums)\n  if k > n:\n    return 0\n  prefix_sum\
    \ = [0] * (n + 1)\n  for i in range(n):\n    prefix_sum[i + 1] = prefix_sum[i]\
    \ + nums[i]\n  max_sum = float('-inf')\n  for i in range(n - k + 1):\n    window_sum\
    \ = prefix_sum[i + k] - prefix_sum[i]\n    max_sum = max(max_sum, window_sum)\n\
    \  return max_sum\n"
  programming_language: python3
  inputs:
  - nums: [1, 2, 3, 4, 5]
    k: 3
  - nums: [1, 2, 3, 4, 5]
    k: 4
  - nums: [1, 2, 3, 4, 5]
    k: 5
  - nums: [1, 2, 3, 4, 5]
    k: 6
  - nums: [1, 2, 3, 4, 5]
    k: 1
  - nums: [1, 2, 3, 4, 5]
    k: 2
  - nums: [1, 2, 3, 4, 5]
    k: 7
  - nums: [1, 2, 3, 4, 5]
    k: 8
  - nums: [1, 2, 3, 4, 5]
    k: 9
  - nums: [1, 2, 3, 4, 5]
    k: 10
  - nums: [1, 2, 3, 4, 5]
    k: 11
  - nums: [1, 2, 3, 4, 5]
    k: 12
  - nums: [1, 2, 3, 4, 5]
    k: 13
  - nums: [1, 2, 3, 4, 5]
    k: 14
  - nums: [1, 2, 3, 4, 5]
    k: 15
  - nums: [1, 2, 3, 4, 5]
    k: 16
  - nums: [1, 2, 3, 4, 5]
    k: 17
  - nums: [1, 2, 3, 4, 5]
    k: 18
  - nums: [1, 2, 3, 4, 5]
    k: 19
  - nums: [1, 2, 3, 4, 5]
    k: 20
  exec_results: [12, 14, 15, 0, 5, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
tree:
  operation: null
  middle_state: null
  content:
    description: "**Maximum Subarray Sum with K Consecutive Elements**\n\nGiven an\
      \ array of integers `nums` and an integer `k`, find the maximum sum of a subarray\
      \ of length `k` that appears in `nums`. If no such subarray exists, return 0.\n\
      \nA subarray is a contiguous part of an array.\n\n**Example 1:**\n\n  Input:\
      \ nums = [1,2,3,4,5], k = 3\n  Output: 12\n  Explanation: The maximum sum is\
      \ 1 + 2 + 3 = 6, but the subarray [1,2,3] appears more than once, so the answer\
      \ is the maximum sum which is 1 + 2 + 3 + 4 = 10, but the maximum sum is 1 +\
      \ 2 + 3 = 6 + 5 = 11, but the maximum sum is 1 + 2 + 3 + 4 + 5 = 15, so the\
      \ answer is 15\n\n**Example 2:**\n\n  Input: nums = [1,2], k = 3\n  Output:\
      \ 0\n  Explanation: The length of the array is 2, so the maximum sum of a subarray\
      \ of length 3 that appears in `nums` is 0.\n\n**Constraints:**\n\n  * `1 <=\
      \ nums.length <= 10^5`\n  * `1 <= k <= nums.length`\n  * `-10^4 <= nums[i] <=\
      \ 10^4`\n"
    code: "def main(nums, k):\n  n = len(nums)\n  if k > n:\n    return 0\n  prefix_sum\
      \ = [0] * (n + 1)\n  for i in range(n):\n    prefix_sum[i + 1] = prefix_sum[i]\
      \ + nums[i]\n  max_sum = float('-inf')\n  for i in range(n - k + 1):\n    window_sum\
      \ = prefix_sum[i + k] - prefix_sum[i]\n    max_sum = max(max_sum, window_sum)\n\
      \  return max_sum\n"
    programming_language: python3
    inputs:
    - nums: [1, 2, 3, 4, 5]
      k: 3
    - nums: [1, 2, 3, 4, 5]
      k: 4
    - nums: [1, 2, 3, 4, 5]
      k: 5
    - nums: [1, 2, 3, 4, 5]
      k: 6
    - nums: [1, 2, 3, 4, 5]
      k: 1
    - nums: [1, 2, 3, 4, 5]
      k: 2
    - nums: [1, 2, 3, 4, 5]
      k: 7
    - nums: [1, 2, 3, 4, 5]
      k: 8
    - nums: [1, 2, 3, 4, 5]
      k: 9
    - nums: [1, 2, 3, 4, 5]
      k: 10
    - nums: [1, 2, 3, 4, 5]
      k: 11
    - nums: [1, 2, 3, 4, 5]
      k: 12
    - nums: [1, 2, 3, 4, 5]
      k: 13
    - nums: [1, 2, 3, 4, 5]
      k: 14
    - nums: [1, 2, 3, 4, 5]
      k: 15
    - nums: [1, 2, 3, 4, 5]
      k: 16
    - nums: [1, 2, 3, 4, 5]
      k: 17
    - nums: [1, 2, 3, 4, 5]
      k: 18
    - nums: [1, 2, 3, 4, 5]
      k: 19
    - nums: [1, 2, 3, 4, 5]
      k: 20
    exec_results: [12, 14, 15, 0, 5, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  children:
  - operation: ['1. Convert the recursive function calls within the ''main'' function
        in the ''code'' key into an iterative approach using a stack data structure,
        carefully managing function call and return stack.', 'Convert the iterative
        approach back into the original recursive function calls, preserving the original
        logic and function call order.']
    middle_state:
      description: "**Maximum Subarray Sum with K Consecutive Elements**\n\nGiven\
        \ an array of integers `nums` and an integer `k`, find the maximum sum of\
        \ a subarray of length `k` that appears in `nums`. If no such subarray exists,\
        \ return 0.\n\nA subarray is a contiguous part of an array.\n\n**Example 1:**\n\
        \n  Input: nums = [1,2,3,4,5], k = 3\n  Output: 12\n  Explanation: The maximum\
        \ sum is 1 + 2 + 3 = 6, but the subarray [1,2,3] appears more than once, so\
        \ the answer is the maximum sum which is 1 + 2 + 3 + 4 = 10, but the maximum\
        \ sum is 1 + 2 + 3 = 6 + 5 = 11, but the maximum sum is 1 + 2 + 3 + 4 + 5\
        \ = 15, so the answer is 15\n\n**Example 2:**\n\n  Input: nums = [1,2], k\
        \ = 3\n  Output: 0\n  Explanation: The length of the array is 2, so the maximum\
        \ sum of a subarray of length 3 that appears in `nums` is 0.\n\n**Constraints:**\n\
        \n  * `1 <= nums.length <= 10^5`\n  * `1 <= k <= nums.length`\n  * `-10^4\
        \ <= nums[i] <= 10^4`\n"
      code: "def main(nums, k):\n  n = len(nums)\n  if k > n:\n    return 0\n  max_sum\
        \ = float('-inf')\n  window_start = 0\n  current_sum = 0\n  for window_end\
        \ in range(n):\n    current_sum += nums[window_end]\n    if window_end >=\
        \ k - 1:\n      max_sum = max(max_sum, current_sum)\n      current_sum -=\
        \ nums[window_start]\n      window_start += 1\n  return max_sum"
      programming_language: python3
      inputs:
      - nums: [1, 2, 3, 4, 5]
        k: 3
      - nums: [1, 2, 3, 4, 5]
        k: 4
      - nums: [1, 2, 3, 4, 5]
        k: 5
      - nums: [1, 2, 3, 4, 5]
        k: 6
      - nums: [1, 2, 3, 4, 5]
        k: 1
      - nums: [1, 2, 3, 4, 5]
        k: 2
      - nums: [1, 2, 3, 4, 5]
        k: 7
      - nums: [1, 2, 3, 4, 5]
        k: 8
      - nums: [1, 2, 3, 4, 5]
        k: 9
      - nums: [1, 2, 3, 4, 5]
        k: 10
      - nums: [1, 2, 3, 4, 5]
        k: 11
      - nums: [1, 2, 3, 4, 5]
        k: 12
      - nums: [1, 2, 3, 4, 5]
        k: 13
      - nums: [1, 2, 3, 4, 5]
        k: 14
      - nums: [1, 2, 3, 4, 5]
        k: 15
      - nums: [1, 2, 3, 4, 5]
        k: 16
      - nums: [1, 2, 3, 4, 5]
        k: 17
      - nums: [1, 2, 3, 4, 5]
        k: 18
      - nums: [1, 2, 3, 4, 5]
        k: 19
      - nums: [1, 2, 3, 4, 5]
        k: 20
      exec_results: [12, 14, 15, 0, 5, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    content:
      description: "**Maximum Subarray Sum with K Consecutive Elements**\n\nGiven\
        \ an array of integers `nums` and an integer `k`, find the maximum sum of\
        \ a subarray of length `k` that appears in `nums`. If no such subarray exists,\
        \ return 0.\n\nA subarray is a contiguous part of an array.\n\n**Example 1:**\n\
        \n  Input: nums = [1,2,3,4,5], k = 3\n  Output: 12\n  Explanation: The maximum\
        \ sum is 1 + 2 + 3 = 6, but the subarray [1,2,3] appears more than once, so\
        \ the answer is the maximum sum which is 1 + 2 + 3 + 4 = 10, but the maximum\
        \ sum is 1 + 2 + 3 = 6 + 5 = 11, but the maximum sum is 1 + 2 + 3 + 4 + 5\
        \ = 15, so the answer is 15\n\n**Example 2:**\n\n  Input: nums = [1,2], k\
        \ = 3\n  Output: 0\n  Explanation: The length of the array is 2, so the maximum\
        \ sum of a subarray of length 3 that appears in `nums` is 0.\n\n**Constraints:**\n\
        \n  * `1 <= nums.length <= 10^5`\n  * `1 <= k <= nums.length`\n  * `-10^4\
        \ <= nums[i] <= 10^4`\n"
      code: "def main(nums, k):\n  def max_subarray_sum(nums, k, window_start):\n\
        \    if k == 1:\n      return nums[0]\n    max_sum = float('-inf')\n    current_sum\
        \ = 0\n    for window_end in range(len(nums)):\n      current_sum += nums[window_end]\n\
        \      if window_end >= k - 1:\n        max_sum = max(max_sum, current_sum)\n\
        \        current_sum -= nums[window_start]\n        window_start += 1\n  \
        \  return max_sum\n  return max_subarray_sum(nums, k, 0)"
      programming_language: python3
      inputs:
      - nums: [1, 2, 3, 4, 5]
        k: 3
      - nums: [1, 2, 3, 4, 5]
        k: 4
      - nums: [1, 2, 3, 4, 5]
        k: 5
      - nums: [1, 2, 3, 4, 5]
        k: 6
      - nums: [1, 2, 3, 4, 5]
        k: 1
      - nums: [1, 2, 3, 4, 5]
        k: 2
      - nums: [1, 2, 3, 4, 5]
        k: 7
      - nums: [1, 2, 3, 4, 5]
        k: 8
      - nums: [1, 2, 3, 4, 5]
        k: 9
      - nums: [1, 2, 3, 4, 5]
        k: 10
      - nums: [1, 2, 3, 4, 5]
        k: 11
      - nums: [1, 2, 3, 4, 5]
        k: 12
      - nums: [1, 2, 3, 4, 5]
        k: 13
      - nums: [1, 2, 3, 4, 5]
        k: 14
      - nums: [1, 2, 3, 4, 5]
        k: 15
      - nums: [1, 2, 3, 4, 5]
        k: 16
      - nums: [1, 2, 3, 4, 5]
        k: 17
      - nums: [1, 2, 3, 4, 5]
        k: 18
      - nums: [1, 2, 3, 4, 5]
        k: 19
      - nums: [1, 2, 3, 4, 5]
        k: 20
      exec_results: [12, 14, 15, -.inf, 1, 9, -.inf, -.inf, -.inf, -.inf, -.inf, -.inf,
        -.inf, -.inf, -.inf, -.inf, -.inf, -.inf, -.inf, -.inf]
    children: []
  - operation: ['2. Utilize a non-standard but equivalent mathematical approach to
        calculate the ''result'' variable in the ''main'' function in the ''code''
        key, replacing arithmetic operations with bitwise operations and cleverly
        using bitwise properties.', 'Revert the ''result'' calculation back to the
        standard arithmetic operations, ensuring the result remains identical.']
    middle_state:
      description: "**Maximum Subarray Sum with K Consecutive Elements**\n\nGiven\
        \ an array of integers `nums` and an integer `k`, find the maximum sum of\
        \ a subarray of length `k` that appears in `nums`. If no such subarray exists,\
        \ return 0.\n\nA subarray is a contiguous part of an array.\n\n**Example 1:**\n\
        \n  Input: nums = [1,2,3,4,5], k = 3\n  Output: 12\n  Explanation: The maximum\
        \ sum is 1 + 2 + 3 = 6, but the subarray [1,2,3] appears more than once, so\
        \ the answer is the maximum sum which is 1 + 2 + 3 + 4 = 10, but the maximum\
        \ sum is 1 + 2 + 3 = 6 + 5 = 11, but the maximum sum is 1 + 2 + 3 + 4 + 5\
        \ = 15, so the answer is 15\n\n**Example 2:**\n\n  Input: nums = [1,2], k\
        \ = 3\n  Output: 0\n  Explanation: The length of the array is 2, so the maximum\
        \ sum of a subarray of length 3 that appears in `nums` is 0.\n\n**Constraints:**\n\
        \n  * `1 <= nums.length <= 10^5`\n  * `1 <= k <= nums.length`\n  * `-10^4\
        \ <= nums[i] <= 10^4`\n"
      code: "def main(nums, k):\n  n = len(nums)\n  if k > n:\n    return 0\n  prefix_sum\
        \ = [0] * (n + 1)\n  for i in range(n):\n    prefix_sum[i + 1] = (prefix_sum[i]\
        \ ^ nums[i] & (~0)) & (~0)\n  max_sum = -2**63\n  for i in range(n - k + 1):\n\
        \    window_sum = ((prefix_sum[i + k] & (~0)) ^ (~0)) - (prefix_sum[i] & (~0))\n\
        \    max_sum = max(max_sum, window_sum)\n  return max_sum"
      programming_language: python3
      inputs:
      - nums: [1, 2, 3, 4, 5]
        k: 3
      - nums: [1, 2, 3, 4, 5]
        k: 4
      - nums: [1, 2, 3, 4, 5]
        k: 5
      - nums: [1, 2, 3, 4, 5]
        k: 6
      - nums: [1, 2, 3, 4, 5]
        k: 1
      - nums: [1, 2, 3, 4, 5]
        k: 2
      - nums: [1, 2, 3, 4, 5]
        k: 7
      - nums: [1, 2, 3, 4, 5]
        k: 8
      - nums: [1, 2, 3, 4, 5]
        k: 9
      - nums: [1, 2, 3, 4, 5]
        k: 10
      - nums: [1, 2, 3, 4, 5]
        k: 11
      - nums: [1, 2, 3, 4, 5]
        k: 12
      - nums: [1, 2, 3, 4, 5]
        k: 13
      - nums: [1, 2, 3, 4, 5]
        k: 14
      - nums: [1, 2, 3, 4, 5]
        k: 15
      - nums: [1, 2, 3, 4, 5]
        k: 16
      - nums: [1, 2, 3, 4, 5]
        k: 17
      - nums: [1, 2, 3, 4, 5]
        k: 18
      - nums: [1, 2, 3, 4, 5]
        k: 19
      - nums: [1, 2, 3, 4, 5]
        k: 20
      exec_results: [-1, -3, -2, 0, -2, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0]
    content:
      description: "**Maximum Subarray Sum with K Consecutive Elements**\n\nGiven\
        \ an array of integers `nums` and an integer `k`, find the maximum sum of\
        \ a subarray of length `k` that appears in `nums`. If no such subarray exists,\
        \ return 0.\n\nA subarray is a contiguous part of an array.\n\n**Example 1:**\n\
        \n  Input: nums = [1,2,3,4,5], k = 3\n  Output: 12\n  Explanation: The maximum\
        \ sum is 1 + 2 + 3 = 6, but the subarray [1,2,3] appears more than once, so\
        \ the answer is the maximum sum which is 1 + 2 + 3 + 4 = 10, but the maximum\
        \ sum is 1 + 2 + 3 = 6 + 5 = 11, but the maximum sum is 1 + 2 + 3 + 4 + 5\
        \ = 15, so the answer is 15\n\n**Example 2:**\n\n  Input: nums = [1,2], k\
        \ = 3\n  Output: 0\n  Explanation: The length of the array is 2, so the maximum\
        \ sum of a subarray of length 3 that appears in `nums` is 0.\n\n**Constraints:**\n\
        \n  * `1 <= nums.length <= 10^5`\n  * `1 <= k <= nums.length`\n  * `-10^4\
        \ <= nums[i] <= 10^4`\n"
      code: "def main(nums, k):\n  n = len(nums)\n  if k > n:\n    return 0\n  prefix_sum\
        \ = [0] * (n + 1)\n  for i in range(n):\n    prefix_sum[i + 1] = prefix_sum[i]\
        \ + nums[i]\n  max_sum = -2**63\n  for i in range(n - k + 1):\n    window_sum\
        \ = prefix_sum[i + k] - prefix_sum[i]\n    max_sum = max(max_sum, window_sum)\n\
        \  return max_sum"
      programming_language: python3
      inputs:
      - nums: [1, 2, 3, 4, 5]
        k: 3
      - nums: [1, 2, 3, 4, 5]
        k: 4
      - nums: [1, 2, 3, 4, 5]
        k: 5
      - nums: [1, 2, 3, 4, 5]
        k: 6
      - nums: [1, 2, 3, 4, 5]
        k: 1
      - nums: [1, 2, 3, 4, 5]
        k: 2
      - nums: [1, 2, 3, 4, 5]
        k: 7
      - nums: [1, 2, 3, 4, 5]
        k: 8
      - nums: [1, 2, 3, 4, 5]
        k: 9
      - nums: [1, 2, 3, 4, 5]
        k: 10
      - nums: [1, 2, 3, 4, 5]
        k: 11
      - nums: [1, 2, 3, 4, 5]
        k: 12
      - nums: [1, 2, 3, 4, 5]
        k: 13
      - nums: [1, 2, 3, 4, 5]
        k: 14
      - nums: [1, 2, 3, 4, 5]
        k: 15
      - nums: [1, 2, 3, 4, 5]
        k: 16
      - nums: [1, 2, 3, 4, 5]
        k: 17
      - nums: [1, 2, 3, 4, 5]
        k: 18
      - nums: [1, 2, 3, 4, 5]
        k: 19
      - nums: [1, 2, 3, 4, 5]
        k: 20
      exec_results: [12, 14, 15, 0, 5, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    children: []
  - operation: ['3. Replace the ''if-else'' statements within the ''main'' function
        in the ''code'' key with a complex decision tree data structure, utilizing
        a combination of binary search and hash tables to evaluate conditions.', 'Convert
        the decision tree back into the original ''if-else'' statements, preserving
        the original logic and condition evaluations.']
    middle_state:
      description: "**Maximum Subarray Sum with K Consecutive Elements**\n\nGiven\
        \ an array of integers `nums` and an integer `k`, find the maximum sum of\
        \ a subarray of length `k` that appears in `nums`. If no such subarray exists,\
        \ return 0.\n\nA subarray is a contiguous part of an array.\n\n**Example 1:**\n\
        \n  Input: nums = [1,2,3,4,5], k = 3\n  Output: 12\n  Explanation: The maximum\
        \ sum is 1 + 2 + 3 = 6, but the subarray [1,2,3] appears more than once, so\
        \ the answer is the maximum sum which is 1 + 2 + 3 + 4 = 10, but the maximum\
        \ sum is 1 + 2 + 3 = 6 + 5 = 11, but the maximum sum is 1 + 2 + 3 + 4 + 5\
        \ = 15, so the answer is 15\n\n**Example 2:**\n\n  Input: nums = [1,2], k\
        \ = 3\n  Output: 0\n  Explanation: The length of the array is 2, so the maximum\
        \ sum of a subarray of length 3 that appears in `nums` is 0.\n\n**Constraints:**\n\
        \n  * `1 <= nums.length <= 10^5`\n  * `1 <= k <= nums.length`\n  * `-10^4\
        \ <= nums[i] <= 10^4`\n"
      code: "function Node(key, value) {\n    this.key = key;\n    this.value = value;\n\
        \    this.left = null;\n    this.right = null;\n}\n\nfunction DecisionTree()\
        \ {\n    this.root = null;\n}\n\nDecisionTree.prototype.insert = function(key,\
        \ value) {\n    if (this.root === null) {\n        this.root = new Node(key,\
        \ value);\n    } else {\n        this._insertRecursive(this.root, key, value);\n\
        \    }\n};\n\nDecisionTree.prototype._insertRecursive = function(node, key,\
        \ value) {\n    if (key < node.key) {\n        if (node.left === null) {\n\
        \            node.left = new Node(key, value);\n        } else {\n       \
        \     this._insertRecursive(node.left, key, value);\n        }\n    } else\
        \ {\n        if (node.right === null) {\n            node.right = new Node(key,\
        \ value);\n        } else {\n            this._insertRecursive(node.right,\
        \ key, value);\n        }\n    }\n};\n\nDecisionTree.prototype.search = function(key)\
        \ {\n    return this._searchRecursive(this.root, key);\n};\n\nDecisionTree.prototype._searchRecursive\
        \ = function(node, key) {\n    if (node === null) {\n        return null;\n\
        \    }\n    if (key === node.key) {\n        return node.value;\n    }\n \
        \   if (key < node.key) {\n        return this._searchRecursive(node.left,\
        \ key);\n    }\n    return this._searchRecursive(node.right, key);\n};\n\n\
        function main(nums, k) {\n    n = nums.length;\n    if (k > n) {\n       \
        \ return 0;\n    }\n    const prefix_sum = new Array(n + 1).fill(0);\n   \
        \ for (let i = 0; i < n; i++) {\n        prefix_sum[i + 1] = prefix_sum[i]\
        \ + nums[i];\n    }\n    const max_sum = new DecisionTree();\n    max_sum.insert(0,\
        \ -Infinity);\n    for (let i = 0; i < n - k + 1; i++) {\n        const window_sum\
        \ = prefix_sum[i + k] - prefix_sum[i];\n        const node = max_sum.search(window_sum);\n\
        \        if (node === null) {\n            max_sum.insert(window_sum, window_sum);\n\
        \        } else {\n            max_sum.insert(window_sum, Math.max(node.value,\
        \ window_sum));\n        }\n    }\n    return max_sum.search(0);\n}"
      programming_language: javascript
      inputs:
      - nums: [1, 2, 3, 4, 5]
        k: 3
      - nums: [1, 2, 3, 4, 5]
        k: 4
      - nums: [1, 2, 3, 4, 5]
        k: 5
      - nums: [1, 2, 3, 4, 5]
        k: 6
      - nums: [1, 2, 3, 4, 5]
        k: 1
      - nums: [1, 2, 3, 4, 5]
        k: 2
      - nums: [1, 2, 3, 4, 5]
        k: 7
      - nums: [1, 2, 3, 4, 5]
        k: 8
      - nums: [1, 2, 3, 4, 5]
        k: 9
      - nums: [1, 2, 3, 4, 5]
        k: 10
      - nums: [1, 2, 3, 4, 5]
        k: 11
      - nums: [1, 2, 3, 4, 5]
        k: 12
      - nums: [1, 2, 3, 4, 5]
        k: 13
      - nums: [1, 2, 3, 4, 5]
        k: 14
      - nums: [1, 2, 3, 4, 5]
        k: 15
      - nums: [1, 2, 3, 4, 5]
        k: 16
      - nums: [1, 2, 3, 4, 5]
        k: 17
      - nums: [1, 2, 3, 4, 5]
        k: 18
      - nums: [1, 2, 3, 4, 5]
        k: 19
      - nums: [1, 2, 3, 4, 5]
        k: 20
      exec_results: []
    content:
      description: "**Maximum Subarray Sum with K Consecutive Elements**\n\nGiven\
        \ an array of integers `nums` and an integer `k`, find the maximum sum of\
        \ a subarray of length `k` that appears in `nums`. If no such subarray exists,\
        \ return 0.\n\nA subarray is a contiguous part of an array.\n\n**Example 1:**\n\
        \n  Input: nums = [1,2,3,4,5], k = 3\n  Output: 12\n  Explanation: The maximum\
        \ sum is 1 + 2 + 3 = 6, but the subarray [1,2,3] appears more than once, so\
        \ the answer is the maximum sum which is 1 + 2 + 3 + 4 = 10, but the maximum\
        \ sum is 1 + 2 + 3 = 6 + 5 = 11, but the maximum sum is 1 + 2 + 3 + 4 + 5\
        \ = 15, so the answer is 15\n\n**Example 2:**\n\n  Input: nums = [1,2], k\
        \ = 3\n  Output: 0\n  Explanation: The length of the array is 2, so the maximum\
        \ sum of a subarray of length 3 that appears in `nums` is 0.\n\n**Constraints:**\n\
        \n  * `1 <= nums.length <= 10^5`\n  * `1 <= k <= nums.length`\n  * `-10^4\
        \ <= nums[i] <= 10^4`\n"
      code: "function main(nums, k) {\n    let n = nums.length;\n    if (k > n) {\n\
        \        return 0;\n    }\n    let prefix_sum = new Array(n + 1).fill(0);\n\
        \    for (let i = 0; i < n; i++) {\n        prefix_sum[i + 1] = prefix_sum[i]\
        \ + nums[i];\n    }\n    let max_sum = -Infinity;\n    for (let i = 0; i <\
        \ n - k + 1; i++) {\n        let window_sum = prefix_sum[i + k] - prefix_sum[i];\n\
        \        let max_window_sum = 0;\n        for (let j = i; j < i + k; j++)\
        \ {\n            if (nums[j] > max_window_sum) {\n                max_window_sum\
        \ = nums[j];\n            }\n        }\n        if (window_sum > max_sum)\
        \ {\n            max_sum = window_sum;\n        }\n    }\n    return max_sum;\n\
        }"
      programming_language: javascript
      inputs:
      - nums: [1, 2, 3, 4, 5]
        k: 3
      - nums: [1, 2, 3, 4, 5]
        k: 4
      - nums: [1, 2, 3, 4, 5]
        k: 5
      - nums: [1, 2, 3, 4, 5]
        k: 6
      - nums: [1, 2, 3, 4, 5]
        k: 1
      - nums: [1, 2, 3, 4, 5]
        k: 2
      - nums: [1, 2, 3, 4, 5]
        k: 7
      - nums: [1, 2, 3, 4, 5]
        k: 8
      - nums: [1, 2, 3, 4, 5]
        k: 9
      - nums: [1, 2, 3, 4, 5]
        k: 10
      - nums: [1, 2, 3, 4, 5]
        k: 11
      - nums: [1, 2, 3, 4, 5]
        k: 12
      - nums: [1, 2, 3, 4, 5]
        k: 13
      - nums: [1, 2, 3, 4, 5]
        k: 14
      - nums: [1, 2, 3, 4, 5]
        k: 15
      - nums: [1, 2, 3, 4, 5]
        k: 16
      - nums: [1, 2, 3, 4, 5]
        k: 17
      - nums: [1, 2, 3, 4, 5]
        k: 18
      - nums: [1, 2, 3, 4, 5]
        k: 19
      - nums: [1, 2, 3, 4, 5]
        k: 20
      exec_results: []
    children: []
