operations:
- ['1. Convert the recursive function calls within the ''main'' function in the ''code''
    key into an iterative approach using a stack data structure, carefully managing
    function call and return stack.', 'Convert the iterative approach back into the
    original recursive function calls, preserving the original logic and function
    call order.']
- ['2. Utilize a non-standard but equivalent mathematical approach to calculate the
    ''result'' variable in the ''main'' function in the ''code'' key, replacing arithmetic
    operations with bitwise operations and cleverly using bitwise properties.', 'Revert
    the ''result'' calculation back to the standard arithmetic operations, ensuring
    the result remains identical.']
- ['3. Replace the ''if-else'' statements within the ''main'' function in the ''code''
    key with a complex decision tree data structure, utilizing a combination of binary
    search and hash tables to evaluate conditions.', 'Convert the decision tree back
    into the original ''if-else'' statements, preserving the original logic and condition
    evaluations.']
metrics:
  embedding similarity L-1 AVG: 0.9269237835325912
  embedding similarity L-1: [0.8702321956751243, 0.9999999999999998, 0.9105391549226495]
  BLEU L-1 AVG: 0.34084580424089167
  BLEU L-1: [0.02253741272267485, 1.0, 0]
  ROUGE-rouge1 L-1 AVG: 0.39999999999999997
  ROUGE-rouge1 L-1: [0.20000000000000004, 1.0, 0.0]
  ROUGE-rouge2 L-1 AVG: 0.3684210526315789
  ROUGE-rouge2 L-1: [0.10526315789473684, 1.0, 0.0]
  ROUGE-rougeL L-1 AVG: 0.39999999999999997
  ROUGE-rougeL L-1: [0.20000000000000004, 1.0, 0.0]
  embedding similarity L-2 AVG: 0.0
  embedding similarity L-2: []
  BLEU L-2 AVG: 0.0
  BLEU L-2: []
  ROUGE-rouge1 L-2 AVG: 0.0
  ROUGE-rouge1 L-2: []
  ROUGE-rouge2 L-2 AVG: 0.0
  ROUGE-rouge2 L-2: []
  ROUGE-rougeL L-2 AVG: 0.0
  ROUGE-rougeL L-2: []
  embedding similarity L-3 AVG: 0.0
  embedding similarity L-3: []
  BLEU L-3 AVG: 0.0
  BLEU L-3: []
  ROUGE-rouge1 L-3 AVG: 0.0
  ROUGE-rouge1 L-3: []
  ROUGE-rouge2 L-3 AVG: 0.0
  ROUGE-rouge2 L-3: []
  ROUGE-rougeL L-3 AVG: 0.0
  ROUGE-rougeL L-3: []
evaluatee_model: {model: fireworks_ai/accounts/fireworks/models/llama-v3p1-8b-instruct,
  temperature: 0.6, api_base: 'https://api.fireworks.ai/inference/v1'}
root_content:
  description: "**Maximum Subarray Sum with K Consecutive Elements**\n\nGiven an array\
    \ of integers `nums` and an integer `k`, find the maximum sum of a subarray of\
    \ length `k` that appears in `nums`. If no such subarray exists, return 0.\n\n\
    A subarray is a contiguous part of an array.\n\n**Example 1:**\n\n  Input: nums\
    \ = [1,2,3,4,5], k = 3\n  Output: 12\n  Explanation: The maximum sum is 1 + 2\
    \ + 3 = 6, but the subarray [1,2,3] appears more than once, so the answer is the\
    \ maximum sum which is 1 + 2 + 3 + 4 = 10, but the maximum sum is 1 + 2 + 3 =\
    \ 6 + 5 = 11, but the maximum sum is 1 + 2 + 3 + 4 + 5 = 15, so the answer is\
    \ 15\n\n**Example 2:**\n\n  Input: nums = [1,2], k = 3\n  Output: 0\n  Explanation:\
    \ The length of the array is 2, so the maximum sum of a subarray of length 3 that\
    \ appears in `nums` is 0.\n\n**Constraints:**\n\n  * `1 <= nums.length <= 10^5`\n\
    \  * `1 <= k <= nums.length`\n  * `-10^4 <= nums[i] <= 10^4`\n"
  code: "def main(nums, k):\n  n = len(nums)\n  if k > n:\n    return 0\n  prefix_sum\
    \ = [0] * (n + 1)\n  for i in range(n):\n    prefix_sum[i + 1] = prefix_sum[i]\
    \ + nums[i]\n  max_sum = float('-inf')\n  for i in range(n - k + 1):\n    window_sum\
    \ = prefix_sum[i + k] - prefix_sum[i]\n    max_sum = max(max_sum, window_sum)\n\
    \  return max_sum\n"
  programming_language: python3
  inputs:
  - nums: [1, 2, 3, 4, 5]
    k: 3
  - nums: [1, 2, 3, 4, 5]
    k: 4
  - nums: [1, 2, 3, 4, 5]
    k: 5
  - nums: [1, 2, 3, 4, 5]
    k: 6
  - nums: [1, 2, 3, 4, 5]
    k: 1
  - nums: [1, 2, 3, 4, 5]
    k: 2
  - nums: [1, 2, 3, 4, 5]
    k: 7
  - nums: [1, 2, 3, 4, 5]
    k: 8
  - nums: [1, 2, 3, 4, 5]
    k: 9
  - nums: [1, 2, 3, 4, 5]
    k: 10
  - nums: [1, 2, 3, 4, 5]
    k: 11
  - nums: [1, 2, 3, 4, 5]
    k: 12
  - nums: [1, 2, 3, 4, 5]
    k: 13
  - nums: [1, 2, 3, 4, 5]
    k: 14
  - nums: [1, 2, 3, 4, 5]
    k: 15
  - nums: [1, 2, 3, 4, 5]
    k: 16
  - nums: [1, 2, 3, 4, 5]
    k: 17
  - nums: [1, 2, 3, 4, 5]
    k: 18
  - nums: [1, 2, 3, 4, 5]
    k: 19
  - nums: [1, 2, 3, 4, 5]
    k: 20
  exec_results: [12, 14, 15, 0, 5, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
tree:
  operation: null
  middle_state: null
  content:
    description: "**Maximum Subarray Sum with K Consecutive Elements**\n\nGiven an\
      \ array of integers `nums` and an integer `k`, find the maximum sum of a subarray\
      \ of length `k` that appears in `nums`. If no such subarray exists, return 0.\n\
      \nA subarray is a contiguous part of an array.\n\n**Example 1:**\n\n  Input:\
      \ nums = [1,2,3,4,5], k = 3\n  Output: 12\n  Explanation: The maximum sum is\
      \ 1 + 2 + 3 = 6, but the subarray [1,2,3] appears more than once, so the answer\
      \ is the maximum sum which is 1 + 2 + 3 + 4 = 10, but the maximum sum is 1 +\
      \ 2 + 3 = 6 + 5 = 11, but the maximum sum is 1 + 2 + 3 + 4 + 5 = 15, so the\
      \ answer is 15\n\n**Example 2:**\n\n  Input: nums = [1,2], k = 3\n  Output:\
      \ 0\n  Explanation: The length of the array is 2, so the maximum sum of a subarray\
      \ of length 3 that appears in `nums` is 0.\n\n**Constraints:**\n\n  * `1 <=\
      \ nums.length <= 10^5`\n  * `1 <= k <= nums.length`\n  * `-10^4 <= nums[i] <=\
      \ 10^4`\n"
    code: "def main(nums, k):\n  n = len(nums)\n  if k > n:\n    return 0\n  prefix_sum\
      \ = [0] * (n + 1)\n  for i in range(n):\n    prefix_sum[i + 1] = prefix_sum[i]\
      \ + nums[i]\n  max_sum = float('-inf')\n  for i in range(n - k + 1):\n    window_sum\
      \ = prefix_sum[i + k] - prefix_sum[i]\n    max_sum = max(max_sum, window_sum)\n\
      \  return max_sum\n"
    programming_language: python3
    inputs:
    - nums: [1, 2, 3, 4, 5]
      k: 3
    - nums: [1, 2, 3, 4, 5]
      k: 4
    - nums: [1, 2, 3, 4, 5]
      k: 5
    - nums: [1, 2, 3, 4, 5]
      k: 6
    - nums: [1, 2, 3, 4, 5]
      k: 1
    - nums: [1, 2, 3, 4, 5]
      k: 2
    - nums: [1, 2, 3, 4, 5]
      k: 7
    - nums: [1, 2, 3, 4, 5]
      k: 8
    - nums: [1, 2, 3, 4, 5]
      k: 9
    - nums: [1, 2, 3, 4, 5]
      k: 10
    - nums: [1, 2, 3, 4, 5]
      k: 11
    - nums: [1, 2, 3, 4, 5]
      k: 12
    - nums: [1, 2, 3, 4, 5]
      k: 13
    - nums: [1, 2, 3, 4, 5]
      k: 14
    - nums: [1, 2, 3, 4, 5]
      k: 15
    - nums: [1, 2, 3, 4, 5]
      k: 16
    - nums: [1, 2, 3, 4, 5]
      k: 17
    - nums: [1, 2, 3, 4, 5]
      k: 18
    - nums: [1, 2, 3, 4, 5]
      k: 19
    - nums: [1, 2, 3, 4, 5]
      k: 20
    exec_results: [12, 14, 15, 0, 5, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  children:
  - operation: ['1. Convert the recursive function calls within the ''main'' function
        in the ''code'' key into an iterative approach using a stack data structure,
        carefully managing function call and return stack.', 'Convert the iterative
        approach back into the original recursive function calls, preserving the original
        logic and function call order.']
    middle_state:
      description: "**Maximum Subarray Sum with K Consecutive Elements**\n\nGiven\
        \ an array of integers `nums` and an integer `k`, find the maximum sum of\
        \ a subarray of length `k` that appears in `nums`. If no such subarray exists,\
        \ return 0.\n\nA subarray is a contiguous part of an array.\n\n**Example 1:**\n\
        \n  Input: nums = [1,2,3,4,5], k = 3\n  Output: 12\n  Explanation: The maximum\
        \ sum is 1 + 2 + 3 = 6, but the subarray [1,2,3] appears more than once, so\
        \ the answer is the maximum sum which is 1 + 2 + 3 + 4 = 10, but the maximum\
        \ sum is 1 + 2 + 3 = 6 + 5 = 11, but the maximum sum is 1 + 2 + 3 + 4 + 5\
        \ = 15, so the answer is 15\n\n**Example 2:**\n\n  Input: nums = [1,2], k\
        \ = 3\n  Output: 0\n  Explanation: The length of the array is 2, so the maximum\
        \ sum of a subarray of length 3 that appears in `nums` is 0.\n\n**Constraints:**\n\
        \n  * `1 <= nums.length <= 10^5`\n  * `1 <= k <= nums.length`\n  * `-10^4\
        \ <= nums[i] <= 10^4`\n"
      code: "def main(nums, k):\n  n = len(nums)\n  if k > n:\n    return 0\n  prefix_sum\
        \ = [0] * (n + 1)\n  stack = []\n  max_sum = float('-inf')\n  for i in range(n):\n\
        \    while stack and stack[-1][0] < i - k + 1:\n      stack.pop()\n    stack.append((i,\
        \ prefix_sum[i]))\n    prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n    if\
        \ i >= k - 1:\n      max_sum = max(max_sum, prefix_sum[i + 1] - stack[0][1])\n\
        \  return max_sum"
      programming_language: python3
      inputs:
      - nums: [1, 2, 3, 4, 5]
        k: 3
      - nums: [1, 2, 3, 4, 5]
        k: 4
      - nums: [1, 2, 3, 4, 5]
        k: 5
      - nums: [1, 2, 3, 4, 5]
        k: 6
      - nums: [1, 2, 3, 4, 5]
        k: 1
      - nums: [1, 2, 3, 4, 5]
        k: 2
      - nums: [1, 2, 3, 4, 5]
        k: 7
      - nums: [1, 2, 3, 4, 5]
        k: 8
      - nums: [1, 2, 3, 4, 5]
        k: 9
      - nums: [1, 2, 3, 4, 5]
        k: 10
      - nums: [1, 2, 3, 4, 5]
        k: 11
      - nums: [1, 2, 3, 4, 5]
        k: 12
      - nums: [1, 2, 3, 4, 5]
        k: 13
      - nums: [1, 2, 3, 4, 5]
        k: 14
      - nums: [1, 2, 3, 4, 5]
        k: 15
      - nums: [1, 2, 3, 4, 5]
        k: 16
      - nums: [1, 2, 3, 4, 5]
        k: 17
      - nums: [1, 2, 3, 4, 5]
        k: 18
      - nums: [1, 2, 3, 4, 5]
        k: 19
      - nums: [1, 2, 3, 4, 5]
        k: 20
      exec_results: [15, 15, 15, 0, 5, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0]
    content:
      description: "**Maximum Subarray Sum with K Consecutive Elements**\n\nGiven\
        \ an array of integers `nums` and an integer `k`, find the maximum sum of\
        \ a subarray of length `k` that appears in `nums`. If no such subarray exists,\
        \ return 0.\n\nA subarray is a contiguous part of an array.\n\n**Example 1:**\n\
        \n  Input: nums = [1,2,3,4,5], k = 3\n  Output: 12\n  Explanation: The maximum\
        \ sum is 1 + 2 + 3 = 6, but the subarray [1,2,3] appears more than once, so\
        \ the answer is the maximum sum which is 1 + 2 + 3 + 4 = 10, but the maximum\
        \ sum is 1 + 2 + 3 = 6 + 5 = 11, but the maximum sum is 1 + 2 + 3 + 4 + 5\
        \ = 15, so the answer is 15\n\n**Example 2:**\n\n  Input: nums = [1,2], k\
        \ = 3\n  Output: 0\n  Explanation: The length of the array is 2, so the maximum\
        \ sum of a subarray of length 3 that appears in `nums` is 0.\n\n**Constraints:**\n\
        \n  * `1 <= nums.length <= 10^5`\n  * `1 <= k <= nums.length`\n  * `-10^4\
        \ <= nums[i] <= 10^4`\n"
      code: "def main(nums, k):\n  def helper(i):\n    if i >= k:\n      return 0\n\
        \    prefix_sum = [0] * (i + 1)\n    stack = []\n    max_sum = float('-inf')\n\
        \    for j in range(i):\n      while stack and stack[-1][0] < j - k + 1:\n\
        \        stack.pop()\n      stack.append((j, prefix_sum[j]))\n      prefix_sum[j\
        \ + 1] = prefix_sum[j] + nums[j]\n      if j >= k - 1:\n        max_sum =\
        \ max(max_sum, prefix_sum[j + 1] - stack[0][1])\n    return max_sum\n  return\
        \ helper(len(nums) - 1)"
      programming_language: python3
      inputs:
      - nums: [1, 2, 3, 4, 5]
        k: 3
      - nums: [1, 2, 3, 4, 5]
        k: 4
      - nums: [1, 2, 3, 4, 5]
        k: 5
      - nums: [1, 2, 3, 4, 5]
        k: 6
      - nums: [1, 2, 3, 4, 5]
        k: 1
      - nums: [1, 2, 3, 4, 5]
        k: 2
      - nums: [1, 2, 3, 4, 5]
        k: 7
      - nums: [1, 2, 3, 4, 5]
        k: 8
      - nums: [1, 2, 3, 4, 5]
        k: 9
      - nums: [1, 2, 3, 4, 5]
        k: 10
      - nums: [1, 2, 3, 4, 5]
        k: 11
      - nums: [1, 2, 3, 4, 5]
        k: 12
      - nums: [1, 2, 3, 4, 5]
        k: 13
      - nums: [1, 2, 3, 4, 5]
        k: 14
      - nums: [1, 2, 3, 4, 5]
        k: 15
      - nums: [1, 2, 3, 4, 5]
        k: 16
      - nums: [1, 2, 3, 4, 5]
        k: 17
      - nums: [1, 2, 3, 4, 5]
        k: 18
      - nums: [1, 2, 3, 4, 5]
        k: 19
      - nums: [1, 2, 3, 4, 5]
        k: 20
      exec_results: [0, 0, -.inf, -.inf, 0, 0, -.inf, -.inf, -.inf, -.inf, -.inf,
        -.inf, -.inf, -.inf, -.inf, -.inf, -.inf, -.inf, -.inf, -.inf]
    children: []
  - operation: ['2. Utilize a non-standard but equivalent mathematical approach to
        calculate the ''result'' variable in the ''main'' function in the ''code''
        key, replacing arithmetic operations with bitwise operations and cleverly
        using bitwise properties.', 'Revert the ''result'' calculation back to the
        standard arithmetic operations, ensuring the result remains identical.']
    middle_state:
      description: "**Maximum Subarray Sum with K Consecutive Elements**\n\nGiven\
        \ an array of integers `nums` and an integer `k`, find the maximum sum of\
        \ a subarray of length `k` that appears in `nums`. If no such subarray exists,\
        \ return 0.\n\nA subarray is a contiguous part of an array.\n\n**Example 1:**\n\
        \n  Input: nums = [1,2,3,4,5], k = 3\n  Output: 12\n  Explanation: The maximum\
        \ sum is 1 + 2 + 3 = 6, but the subarray [1,2,3] appears more than once, so\
        \ the answer is the maximum sum which is 1 + 2 + 3 + 4 = 10, but the maximum\
        \ sum is 1 + 2 + 3 = 6 + 5 = 11, but the maximum sum is 1 + 2 + 3 + 4 + 5\
        \ = 15, so the answer is 15\n\n**Example 2:**\n\n  Input: nums = [1,2], k\
        \ = 3\n  Output: 0\n  Explanation: The length of the array is 2, so the maximum\
        \ sum of a subarray of length 3 that appears in `nums` is 0.\n\n**Constraints:**\n\
        \n  * `1 <= nums.length <= 10^5`\n  * `1 <= k <= nums.length`\n  * `-10^4\
        \ <= nums[i] <= 10^4`\n"
      code: "def main(nums, k):\n  n = len(nums)\n  if k > n:\n    return 0\n  prefix_sum\
        \ = [0] * (n + 1)\n  for i in range(n):\n    prefix_sum[i + 1] = prefix_sum[i]\
        \ ^ (nums[i] & 0xffffffff)\n  max_sum = -2**31\n  for i in range(n - k + 1):\n\
        \    window_sum = (prefix_sum[i + k] ^ prefix_sum[i]) & 0xffffffff\n    max_sum\
        \ = max(max_sum, window_sum)\n  return max_sum"
      programming_language: python3
      inputs:
      - nums: [1, 2, 3, 4, 5]
        k: 3
      - nums: [1, 2, 3, 4, 5]
        k: 4
      - nums: [1, 2, 3, 4, 5]
        k: 5
      - nums: [1, 2, 3, 4, 5]
        k: 6
      - nums: [1, 2, 3, 4, 5]
        k: 1
      - nums: [1, 2, 3, 4, 5]
        k: 2
      - nums: [1, 2, 3, 4, 5]
        k: 7
      - nums: [1, 2, 3, 4, 5]
        k: 8
      - nums: [1, 2, 3, 4, 5]
        k: 9
      - nums: [1, 2, 3, 4, 5]
        k: 10
      - nums: [1, 2, 3, 4, 5]
        k: 11
      - nums: [1, 2, 3, 4, 5]
        k: 12
      - nums: [1, 2, 3, 4, 5]
        k: 13
      - nums: [1, 2, 3, 4, 5]
        k: 14
      - nums: [1, 2, 3, 4, 5]
        k: 15
      - nums: [1, 2, 3, 4, 5]
        k: 16
      - nums: [1, 2, 3, 4, 5]
        k: 17
      - nums: [1, 2, 3, 4, 5]
        k: 18
      - nums: [1, 2, 3, 4, 5]
        k: 19
      - nums: [1, 2, 3, 4, 5]
        k: 20
      exec_results: [5, 4, 1, 0, 5, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    content:
      description: "**Maximum Subarray Sum with K Consecutive Elements**\n\nGiven\
        \ an array of integers `nums` and an integer `k`, find the maximum sum of\
        \ a subarray of length `k` that appears in `nums`. If no such subarray exists,\
        \ return 0.\n\nA subarray is a contiguous part of an array.\n\n**Example 1:**\n\
        \n  Input: nums = [1,2,3,4,5], k = 3\n  Output: 12\n  Explanation: The maximum\
        \ sum is 1 + 2 + 3 = 6, but the subarray [1,2,3] appears more than once, so\
        \ the answer is the maximum sum which is 1 + 2 + 3 + 4 = 10, but the maximum\
        \ sum is 1 + 2 + 3 = 6 + 5 = 11, but the maximum sum is 1 + 2 + 3 + 4 + 5\
        \ = 15, so the answer is 15\n\n**Example 2:**\n\n  Input: nums = [1,2], k\
        \ = 3\n  Output: 0\n  Explanation: The length of the array is 2, so the maximum\
        \ sum of a subarray of length 3 that appears in `nums` is 0.\n\n**Constraints:**\n\
        \n  * `1 <= nums.length <= 10^5`\n  * `1 <= k <= nums.length`\n  * `-10^4\
        \ <= nums[i] <= 10^4`\n"
      code: "def main(nums, k):\n  n = len(nums)\n  if k > n:\n    return 0\n  prefix_sum\
        \ = [0] * (n + 1)\n  for i in range(n):\n    prefix_sum[i + 1] = prefix_sum[i]\
        \ + nums[i]\n  max_sum = float('-inf')\n  for i in range(n - k + 1):\n   \
        \ window_sum = prefix_sum[i + k] - prefix_sum[i]\n    max_sum = max(max_sum,\
        \ window_sum)\n  return max_sum"
      programming_language: python3
      inputs:
      - nums: [1, 2, 3, 4, 5]
        k: 3
      - nums: [1, 2, 3, 4, 5]
        k: 4
      - nums: [1, 2, 3, 4, 5]
        k: 5
      - nums: [1, 2, 3, 4, 5]
        k: 6
      - nums: [1, 2, 3, 4, 5]
        k: 1
      - nums: [1, 2, 3, 4, 5]
        k: 2
      - nums: [1, 2, 3, 4, 5]
        k: 7
      - nums: [1, 2, 3, 4, 5]
        k: 8
      - nums: [1, 2, 3, 4, 5]
        k: 9
      - nums: [1, 2, 3, 4, 5]
        k: 10
      - nums: [1, 2, 3, 4, 5]
        k: 11
      - nums: [1, 2, 3, 4, 5]
        k: 12
      - nums: [1, 2, 3, 4, 5]
        k: 13
      - nums: [1, 2, 3, 4, 5]
        k: 14
      - nums: [1, 2, 3, 4, 5]
        k: 15
      - nums: [1, 2, 3, 4, 5]
        k: 16
      - nums: [1, 2, 3, 4, 5]
        k: 17
      - nums: [1, 2, 3, 4, 5]
        k: 18
      - nums: [1, 2, 3, 4, 5]
        k: 19
      - nums: [1, 2, 3, 4, 5]
        k: 20
      exec_results: [12, 14, 15, 0, 5, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    children: []
  - operation: ['3. Replace the ''if-else'' statements within the ''main'' function
        in the ''code'' key with a complex decision tree data structure, utilizing
        a combination of binary search and hash tables to evaluate conditions.', 'Convert
        the decision tree back into the original ''if-else'' statements, preserving
        the original logic and condition evaluations.']
    middle_state:
      description: "**Maximum Subarray Sum with K Consecutive Elements**\n\nGiven\
        \ an array of integers `nums` and an integer `k`, find the maximum sum of\
        \ a subarray of length `k` that appears in `nums`. If no such subarray exists,\
        \ return 0.\n\nA subarray is a contiguous part of an array.\n\n**Example 1:**\n\
        \n  Input: nums = [1,2,3,4,5], k = 3\n  Output: 12\n  Explanation: The maximum\
        \ sum is 1 + 2 + 3 = 6, but the subarray [1,2,3] appears more than once, so\
        \ the answer is the maximum sum which is 1 + 2 + 3 + 4 = 10, but the maximum\
        \ sum is 1 + 2 + 3 = 6 + 5 = 11, but the maximum sum is 1 + 2 + 3 + 4 + 5\
        \ = 15, so the answer is 15\n\n**Example 2:**\n\n  Input: nums = [1,2], k\
        \ = 3\n  Output: 0\n  Explanation: The length of the array is 2, so the maximum\
        \ sum of a subarray of length 3 that appears in `nums` is 0.\n\n**Constraints:**\n\
        \n  * `1 <= nums.length <= 10^5`\n  * `1 <= k <= nums.length`\n  * `-10^4\
        \ <= nums[i] <= 10^4`\n"
      code: "class Node:\n    def __init__(self, value, left=None, right=None):\n\
        \        self.value = value\n        self.left = left\n        self.right\
        \ = right\n\nclass DecisionTree:\n    def __init__(self, condition, true_branch,\
        \ false_branch):\n        self.condition = condition\n        self.true_branch\
        \ = true_branch\n        self.false_branch = false_branch\n\n    def evaluate(self,\
        \ nums, k):\n        if self.condition(nums, k):\n            return self.true_branch.evaluate(nums,\
        \ k)\n        else:\n            return self.false_branch.evaluate(nums, k)\n\
        \ndef main(nums, k):\n    n = len(nums)\n    decision_tree = DecisionTree(\n\
        \        lambda nums, k: k > n,\n        DecisionTree(\n            lambda\
        \ nums, k: k <= 0,\n            lambda nums, k: DecisionTree(\n          \
        \      lambda nums, k: len(nums) < k,\n                lambda nums, k: 0,\n\
        \                lambda nums, k: DecisionTree(\n                    lambda\
        \ prefix_sum, k: prefix_sum[k] - prefix_sum[0],\n                    DecisionTree(\n\
        \                        lambda prefix_sum, k: prefix_sum[k+1] - prefix_sum[k],\n\
        \                        lambda prefix_sum, k: prefix_sum[k],\n          \
        \              lambda prefix_sum, k: prefix_sum[k+1]\n                   \
        \ ),\n                    lambda prefix_sum, k: prefix_sum[k]\n          \
        \      )\n            ),\n            lambda nums, k: DecisionTree(\n    \
        \            lambda prefix_sum, k: prefix_sum[k] - prefix_sum[0],\n      \
        \          DecisionTree(\n                    lambda prefix_sum, k: prefix_sum[k+1]\
        \ - prefix_sum[k],\n                    lambda prefix_sum, k: prefix_sum[k],\n\
        \                    lambda prefix_sum, k: prefix_sum[k+1]\n             \
        \   ),\n                lambda prefix_sum, k: prefix_sum[k]\n            )\n\
        \        ),\n        lambda nums, k: DecisionTree(\n            lambda prefix_sum,\
        \ k: prefix_sum[k+1] - prefix_sum[0],\n            DecisionTree(\n       \
        \         lambda prefix_sum, k: prefix_sum[k+1] - prefix_sum[k],\n       \
        \         lambda prefix_sum, k: prefix_sum[k],\n                lambda prefix_sum,\
        \ k: prefix_sum[k+1]\n            ),\n            lambda prefix_sum, k: prefix_sum[k]\n\
        \        )\n    )\n    return decision_tree.evaluate([0]*n, k)"
      programming_language: python3
      inputs:
      - nums: [1, 2, 3, 4, 5]
        k: 3
      - nums: [1, 2, 3, 4, 5]
        k: 4
      - nums: [1, 2, 3, 4, 5]
        k: 5
      - nums: [1, 2, 3, 4, 5]
        k: 6
      - nums: [1, 2, 3, 4, 5]
        k: 1
      - nums: [1, 2, 3, 4, 5]
        k: 2
      - nums: [1, 2, 3, 4, 5]
        k: 7
      - nums: [1, 2, 3, 4, 5]
        k: 8
      - nums: [1, 2, 3, 4, 5]
        k: 9
      - nums: [1, 2, 3, 4, 5]
        k: 10
      - nums: [1, 2, 3, 4, 5]
        k: 11
      - nums: [1, 2, 3, 4, 5]
        k: 12
      - nums: [1, 2, 3, 4, 5]
        k: 13
      - nums: [1, 2, 3, 4, 5]
        k: 14
      - nums: [1, 2, 3, 4, 5]
        k: 15
      - nums: [1, 2, 3, 4, 5]
        k: 16
      - nums: [1, 2, 3, 4, 5]
        k: 17
      - nums: [1, 2, 3, 4, 5]
        k: 18
      - nums: [1, 2, 3, 4, 5]
        k: 19
      - nums: [1, 2, 3, 4, 5]
        k: 20
      exec_results: [null, null, null, null, null, null, null, null, null, null, null,
        null, null, null, null, null, null, null, null, null]
    content:
      description: "**Maximum Subarray Sum with K Consecutive Elements**\n\nGiven\
        \ an array of integers `nums` and an integer `k`, find the maximum sum of\
        \ a subarray of length `k` that appears in `nums`. If no such subarray exists,\
        \ return 0.\n\nA subarray is a contiguous part of an array.\n\n**Example 1:**\n\
        \n  Input: nums = [1,2,3,4,5], k = 3\n  Output: 12\n  Explanation: The maximum\
        \ sum is 1 + 2 + 3 = 6, but the subarray [1,2,3] appears more than once, so\
        \ the answer is the maximum sum which is 1 + 2 + 3 + 4 = 10, but the maximum\
        \ sum is 1 + 2 + 3 = 6 + 5 = 11, but the maximum sum is 1 + 2 + 3 + 4 + 5\
        \ = 15, so the answer is 15\n\n**Example 2:**\n\n  Input: nums = [1,2], k\
        \ = 3\n  Output: 0\n  Explanation: The length of the array is 2, so the maximum\
        \ sum of a subarray of length 3 that appears in `nums` is 0.\n\n**Constraints:**\n\
        \n  * `1 <= nums.length <= 10^5`\n  * `1 <= k <= nums.length`\n  * `-10^4\
        \ <= nums[i] <= 10^4`\n"
      code: "def compute_prefix_sum(nums):\n    n = len(nums)\n    prefix_sum = [0]\
        \ * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i]\
        \ + nums[i]\n    return prefix_sum\n\ndef get_kth_smallest(nums, k):\n   \
        \ n = len(nums)\n    if k > n:\n        return -1\n    elif k <= 0:\n    \
        \    return -1\n    elif len(nums) < k:\n        return -1\n    else:\n  \
        \      prefix_sum = compute_prefix_sum(nums)\n        if prefix_sum[k] - prefix_sum[0]\
        \ > prefix_sum[n] - prefix_sum[0]:\n            if prefix_sum[k+1] - prefix_sum[k]\
        \ > 0:\n                return prefix_sum[k+1] - prefix_sum[k]\n         \
        \   else:\n                return prefix_sum[k]\n        else:\n         \
        \   if prefix_sum[k+1] - prefix_sum[k] > 0:\n                return prefix_sum[k]\n\
        \            else:\n                return prefix_sum[k+1]\n\ndef main(nums,\
        \ k):\n    return get_kth_smallest(nums, k)"
      programming_language: python3
      inputs:
      - nums: [1, 2, 3, 4, 5]
        k: 3
      - nums: [1, 2, 3, 4, 5]
        k: 4
      - nums: [1, 2, 3, 4, 5]
        k: 5
      - nums: [1, 2, 3, 4, 5]
        k: 6
      - nums: [1, 2, 3, 4, 5]
        k: 1
      - nums: [1, 2, 3, 4, 5]
        k: 2
      - nums: [1, 2, 3, 4, 5]
        k: 7
      - nums: [1, 2, 3, 4, 5]
        k: 8
      - nums: [1, 2, 3, 4, 5]
        k: 9
      - nums: [1, 2, 3, 4, 5]
        k: 10
      - nums: [1, 2, 3, 4, 5]
        k: 11
      - nums: [1, 2, 3, 4, 5]
        k: 12
      - nums: [1, 2, 3, 4, 5]
        k: 13
      - nums: [1, 2, 3, 4, 5]
        k: 14
      - nums: [1, 2, 3, 4, 5]
        k: 15
      - nums: [1, 2, 3, 4, 5]
        k: 16
      - nums: [1, 2, 3, 4, 5]
        k: 17
      - nums: [1, 2, 3, 4, 5]
        k: 18
      - nums: [1, 2, 3, 4, 5]
        k: 19
      - nums: [1, 2, 3, 4, 5]
        k: 20
      exec_results: [6, 10, null, -1, 1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1]
    children: []
